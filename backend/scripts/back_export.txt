# TOTETAXI - BACKEND CODE SNAPSHOT
# AUTO-GENERATED - CODE FILES ONLY
# Created: 2025-10-31 14:08:46
# Total files: 54
# üîí SECURITY: .env files excluded (contain secrets)
# üìã INCLUDES: All Django apps, migrations, configuration
# Apps: accounts (STAFF), bookings, customers, logistics, payments, services
# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery
# Integration: S3 storage, SES email, mocked Stripe/Onfleet


# ========================= CONFIGURATION & ROOT FILES =========================


# ==== .dockerignore ====

```
# Git
.git
.gitignore

# Docker
.docker
Dockerfile
Dockerfile.prod
docker-compose*

# Python
__pycache__
*.pyc
*.pyo
*.pyd
.Python
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.pytest_cache
.cache
htmlcov
.mypy_cache
.dmypy.json
dmypy.json

# IDEs
.vscode
.idea
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log
npm-debug.log*

# Environment
.env
.env.local
.env.development
.env.production

# Database
*.sqlite3
db.sqlite3

# Media files
media/

# Static files (will be collected in container)
staticfiles/

# Node (if any)
node_modules
npm-debug.log
```

# ==== Dockerfile ====

```dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app \
    PORT=8000

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        postgresql-client \
        build-essential \
        libpq-dev \
        curl \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . /app/

# Create directories for logs and static files
RUN mkdir -p /app/logs /app/staticfiles /app/media

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD curl -f http://localhost:8000/ || exit 1

CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
```

# ==== docker-compose.yml ====

```yaml
name: pa-scheduler-backend

services:
  # PostgreSQL Database - PORT 5436
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: pa_scheduler
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5436:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis for Celery - PORT 6383
  redis:
    image: redis:7-alpine
    ports:
      - "6383:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Django Backend - PORT 8006
  web:
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    ports:
      - "8006:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/pa_scheduler
      - REDIS_URL=redis://redis:6379/0

  # Celery Worker
  celery:
    build: .
    command: celery -A config worker -l info
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/pa_scheduler
      - REDIS_URL=redis://redis:6379/0

  # Celery Beat Scheduler
  celery-beat:
    build: .
    command: celery -A config beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/pa_scheduler
      - REDIS_URL=redis://redis:6379/0

volumes:
  postgres_data:
  static_volume:
  media_volume:
  redis_data:
```

# ==== manage.py ====

```python
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```

# ==== requirements.txt ====

```
# Django Core - Django 5.2 LTS
Django==5.2.7
djangorestframework==3.16.1
django-cors-headers==4.6.0

# Database
psycopg2-binary==2.9.10
dj-database-url==2.2.0

# Authentication
djangorestframework-simplejwt==5.4.0

# Async Tasks
celery==5.5.3
redis==5.2.0
django-celery-beat==2.8.0

# WebSockets
channels==4.3.1
channels-redis==4.2.1
daphne==4.2.1

# Email
boto3==1.35.80

# AI
openai==2.6.1

# Server
gunicorn==23.0.0

# Utilities
python-dotenv==1.0.1
Pillow==11.0.0
```

# ========================= DJANGO PROJECT SETTINGS (config/) =========================


# ==== config/__init__.py ====

```python
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)
```

# ==== config/asgi.py ====

```python
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

django_asgi_app = get_asgi_application()

# Import after Django is set up
from apps.schedules.routing import websocket_urlpatterns

application = ProtocolTypeRouter({
    "http": django_asgi_app,
    "websocket": AuthMiddlewareStack(
        URLRouter(
            websocket_urlpatterns
        )
    ),
})
```

# ==== config/celery.py ====

```python
import os
from celery import Celery
from celery.schedules import crontab

# Set the default Django settings module
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

app = Celery('config')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django apps.
app.autodiscover_tasks()

# Celery Beat Schedule
app.conf.beat_schedule = {
    'check-upcoming-coverage': {
        'task': 'apps.ai.tasks.check_upcoming_coverage',
        'schedule': crontab(hour=6, minute=0),  # Run daily at 6 AM
    },
    'calculate-pa-patterns': {
        'task': 'apps.users.tasks.calculate_all_pa_patterns',
        'schedule': crontab(day_of_week=1, hour=2, minute=0),  # Run weekly Monday 2 AM
    },
}

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
```

# ==== config/settings.py ====

```python
import os
from pathlib import Path
from datetime import timedelta
import dj_database_url

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.environ.get('SECRET_KEY', 'django-insecure-dev-key-change-this-in-production')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.environ.get('DEBUG', 'True') == 'True'

ALLOWED_HOSTS = os.environ.get('ALLOWED_HOSTS', 'localhost,127.0.0.1').split(',')

# Application definition
INSTALLED_APPS = [
    'daphne',  # Must be first for channels
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third-party apps
    'rest_framework',
    'rest_framework_simplejwt',
    'rest_framework_simplejwt.token_blacklist',  # Add this line
    'corsheaders',
    'channels',
    'django_celery_beat',
    
    # Local apps
    'apps.users',
    'apps.schedules',
    'apps.shifts',
    'apps.coverage',
    'apps.ai',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'
ASGI_APPLICATION = 'config.asgi.application'

# Database
DATABASES = {
    'default': dj_database_url.config(
        default=os.environ.get('DATABASE_URL', 'postgres://postgres:postgres@localhost:5436/pa_scheduler'),
        conn_max_age=600
    )
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Custom User Model
AUTH_USER_MODEL = 'users.User'

# REST Framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 50,
}

# JWT Settings
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': True,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
}

# Add to INSTALLED_APPS

# CORS Settings
CORS_ALLOWED_ORIGINS = os.environ.get(
    'CORS_ALLOWED_ORIGINS',
    'http://localhost:3000'
).split(',')

CORS_ALLOW_CREDENTIALS = True

# Celery Configuration
CELERY_BROKER_URL = os.environ.get('REDIS_URL', 'redis://localhost:6383/0')
CELERY_RESULT_BACKEND = os.environ.get('REDIS_URL', 'redis://localhost:6383/0')
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE

# Channels (WebSockets)
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            'hosts': [os.environ.get('REDIS_URL', 'redis://localhost:6383/0')],
        },
    },
}

# Email Configuration (Amazon SES)
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend' if not DEBUG else 'django.core.mail.backends.console.EmailBackend'
EMAIL_HOST = 'email-smtp.us-east-1.amazonaws.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = os.environ.get('AWS_ACCESS_KEY_ID', '')
EMAIL_HOST_PASSWORD = os.environ.get('AWS_SECRET_ACCESS_KEY', '')
DEFAULT_FROM_EMAIL = os.environ.get('DEFAULT_FROM_EMAIL', 'noreply@example.com')

# OpenAI
OPENAI_API_KEY = os.environ.get('OPENAI_API_KEY', '')

# Frontend URL
FRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')
# Logging

# Ensure logs directory exists
LOGS_DIR = BASE_DIR / 'logs'
LOGS_DIR.mkdir(exist_ok=True)

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': LOGS_DIR / 'django.log',
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': os.environ.get('DJANGO_LOG_LEVEL', 'INFO'),
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
```

# ==== config/urls.py ====

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/auth/', include('apps.users.urls')),
]
```

# ==== config/wsgi.py ====

```python
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
```

# ========================= SCRIPTS & UTILITIES =========================


# ==== scripts/back_export.py ====

```python
#!/usr/bin/env python3
"""
ToteTaxi Backend Export - Code Files Only
"""
import os
from pathlib import Path
from datetime import datetime

def get_file_content(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"# Error reading file: {e}"

def should_include_file(file_path, base_dir):
    """Smart file inclusion rules for ToteTaxi Backend - Code Only"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Skip patterns - SECURITY: Handle .env files separately
    skip_patterns = [
        '__pycache__', '.pyc', '.git/', '.pytest_cache/', 'htmlcov/',
        'staticfiles/', 'media/', 'logs/', '.coverage', 'db.sqlite3',
        'back_export.txt', 'totetaxi_backend_snapshot.txt',
        '.DS_Store', '*.swp', '*.swo',
        'README.md', 'CHANGELOG.md'  # Skip documentation files
    ]
    
    if any(pattern in path_str for pattern in skip_patterns):
        return False
    
    # SECURITY: Skip .env files (contain secrets)
    if file_path.name.startswith('.env'):
        return False
    
    # Include patterns - Code files only
    include_extensions = {'.py', '.txt', '.yml', '.yaml', '.toml', '.sh', '.ini', '.conf'}
    include_files = {
        'Dockerfile', 'Dockerfile.dev', '.dockerignore', '.gitignore', 
        'manage.py', 'docker-compose.yml', 'docker-compose.prod.yml',
        'gunicorn.conf.py', 'pytest.ini', 'requirements.txt'
    }
    
    return (
        file_path.suffix in include_extensions or 
        file_path.name in include_files
    )

def categorize_file(file_path, base_dir):
    """Auto-categorize files for ToteTaxi structure"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Configuration files (root level)
    if (rel_path.parent == Path('.') or 
        file_path.name in ['manage.py', 'requirements.txt', 'gunicorn.conf.py', 'pytest.ini']):
        return 'config'
    
    # ToteTaxi Django apps - UPDATED to 6 apps only
    totetaxi_apps = [
        'accounts/', 'bookings/', 'customers/', 
        'logistics/', 'payments/', 'services/'
    ]
    if any(f'apps/{app}' in path_str for app in totetaxi_apps):
        return 'apps'
    
    # Django project settings (config/ directory)
    if 'config/' in path_str:
        return 'project'
    
    # Scripts directory
    if 'scripts/' in path_str:
        return 'scripts'
    
    # Everything else
    return 'other'

def main():
    backend_dir = Path(__file__).parent.parent
    output_file = backend_dir / 'scripts' / 'back_export.txt'
    
    print(f"üîç Auto-discovering ToteTaxi backend files in: {backend_dir}")
    
    # Auto-discover all relevant files
    all_files = []
    for file_path in backend_dir.rglob('*'):
        if file_path.is_file() and should_include_file(file_path, backend_dir):
            all_files.append(file_path)
    
    # Categorize files
    categories = {
        'config': [],
        'project': [],
        'apps': [],
        'scripts': [],
        'other': []
    }
    
    for file_path in all_files:
        category = categorize_file(file_path, backend_dir)
        categories[category].append(file_path)
    
    # Sort within categories
    for category in categories:
        categories[category].sort()
    
    print(f"üìä Found {len(all_files)} files:")
    for cat, files in categories.items():
        if files:
            print(f"  - {cat}: {len(files)} files")
    
    # Generate snapshot
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# TOTETAXI - BACKEND CODE SNAPSHOT\n")
        f.write("# AUTO-GENERATED - CODE FILES ONLY\n")
        f.write(f"# Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# Total files: {len(all_files)}\n")
        f.write("# üîí SECURITY: .env files excluded (contain secrets)\n")
        f.write("# üìã INCLUDES: All Django apps, migrations, configuration\n")
        f.write("# Apps: accounts (STAFF), bookings, customers, logistics, payments, services\n")  # UPDATED
        f.write("# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery\n")
        f.write("# Integration: S3 storage, SES email, mocked Stripe/Onfleet\n\n\n")
        
        # Output by category
        section_names = {
            'config': 'CONFIGURATION & ROOT FILES',
            'project': 'DJANGO PROJECT SETTINGS (config/)',
            'apps': 'DJANGO APPLICATIONS (apps/)',
            'scripts': 'SCRIPTS & UTILITIES',
            'other': 'OTHER FILES'
        }
        
        for category, section_name in section_names.items():
            if categories[category]:
                f.write("# " + "="*25 + f" {section_name} " + "="*25 + "\n\n\n")
                
                for file_path in categories[category]:
                    rel_path = file_path.relative_to(backend_dir)
                    f.write(f"# ==== {rel_path} ====\n\n")
                    
                    # Smart syntax highlighting
                    if file_path.suffix == '.py':
                        f.write("```python\n")
                    elif file_path.suffix in ['.yml', '.yaml']:
                        f.write("```yaml\n")
                    elif file_path.suffix == '.toml':
                        f.write("```toml\n")
                    elif file_path.suffix == '.sh':
                        f.write("```bash\n")
                    elif file_path.name in ['Dockerfile', 'Dockerfile.dev']:
                        f.write("```dockerfile\n")
                    elif file_path.suffix == '.ini':
                        f.write("```ini\n")
                    else:
                        f.write("```\n")
                    
                    content = get_file_content(file_path)
                    f.write(content)
                    if not content.endswith('\n'):
                        f.write('\n')
                    f.write("```\n\n")
    
    print(f"‚úÖ Auto-generated ToteTaxi backend snapshot: {output_file}")
    print("üîí SECURITY: .env files excluded (contain secrets)")
    print("üìã INCLUDES: All 6 Django apps with migrations")  # UPDATED
    print("üèóÔ∏è  STRUCTURE: accounts (staff), bookings, customers, logistics, payments, services")  # UPDATED
    print("üê≥ DOCKER: Configuration and compose files included")
    print("üìÅ CODE ONLY: Documentation files excluded")

if __name__ == "__main__":
    main()
```

# ==== scripts/entrypoint.sh ====

```bash
#!/bin/bash
set -e

echo "Starting ToteTaxi Backend..."

# CRITICAL FIX: Unset docker-compose DB variables on Fly.io
unset DB_HOST
unset DB_NAME
unset DB_USER
unset DB_PASSWORD
unset DB_PORT

# Wait for database if DB_HOST is set (won't happen after unset)
if [ -n "$DB_HOST" ]; then
    echo "Waiting for postgres at $DB_HOST:${DB_PORT:-5432}..."
    while ! pg_isready -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "${DB_USER:-postgres}"; do
      sleep 1
    done
    echo "PostgreSQL is ready!"
fi

# Run migrations
echo "Running database migrations..."
python manage.py migrate --no-input

# Collect static files (in case not done in Dockerfile)
echo "Collecting static files..."
python manage.py collectstatic --no-input --clear || true

# Create cache table if needed
python manage.py createcachetable || true

# Create superuser if specified (optional)
if [ -n "$DJANGO_SUPERUSER_EMAIL" ] && [ -n "$DJANGO_SUPERUSER_PASSWORD" ]; then
    echo "Creating superuser..."
    python manage.py shell -c "
from django.contrib.auth import get_user_model
User = get_user_model()
if not User.objects.filter(email='$DJANGO_SUPERUSER_EMAIL').exists():
    User.objects.create_superuser('$DJANGO_SUPERUSER_EMAIL', '$DJANGO_SUPERUSER_EMAIL', '$DJANGO_SUPERUSER_PASSWORD')
    print('Superuser created')
else:
    print('Superuser already exists')
" || true
fi

echo "Starting application..."
exec "$@"
```

# ==== scripts/validate_ses_setup.py ====

```python
# backend/scripts/validate_ses_setup.py
"""
Validate SES setup for production
Run locally: docker-compose exec web python manage.py shell < scripts/validate_ses_setup.py
Run on Fly.io: fly ssh console -a totetaxi-backend -C "python manage.py shell < scripts/validate_ses_setup.py"
"""
import sys
from django.core.mail import send_mail
from django.conf import settings

print("üîç Validating SES Configuration...")
print(f"EMAIL_BACKEND: {settings.EMAIL_BACKEND}")
print(f"EMAIL_HOST: {settings.EMAIL_HOST}")
print(f"EMAIL_PORT: {settings.EMAIL_PORT}")
print(f"EMAIL_USE_TLS: {settings.EMAIL_USE_TLS}")
print(f"DEFAULT_FROM_EMAIL: {settings.DEFAULT_FROM_EMAIL}")

# Check if using SES in production
if 'ses' not in settings.EMAIL_BACKEND.lower() and not settings.DEBUG:
    print("‚ö†Ô∏è  WARNING: Not using SES backend in production!")
    print(f"Current backend: {settings.EMAIL_BACKEND}")
    sys.exit(1)

# In local dev, skip SES validation
if settings.DEBUG and 'console' in settings.EMAIL_BACKEND.lower():
    print("‚ÑπÔ∏è  Running in DEBUG mode with console backend - SES validation skipped")
    print("‚úÖ Email configuration is correct for local development")
    sys.exit(0)

print("\nüìß Sending test email to mnraynor90@gmail.com...")
try:
    send_mail(
        subject='ToteTaxi SES Test - Production Email Validation',
        message='''This is a test email from ToteTaxi to validate SES setup.

If you received this email, your SES configuration is working correctly!

Test Details:
- Backend: {backend}
- From: {from_email}
- Host: {host}
- Port: {port}

Next steps:
1. Check AWS SES dashboard for delivery metrics
2. Verify email templates are rendering correctly
3. Test all email types (welcome, verification, password reset, bookings)

ToteTaxi Backend Team
'''.format(
            backend=settings.EMAIL_BACKEND,
            from_email=settings.DEFAULT_FROM_EMAIL,
            host=settings.EMAIL_HOST,
            port=settings.EMAIL_PORT
        ),
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=['mnraynor90@gmail.com'],
        fail_silently=False,
    )
    print("‚úÖ Test email sent successfully!")
    print("üì¨ Check mnraynor90@gmail.com inbox to confirm delivery.")
    print("\n‚ú® SES validation complete!")
except Exception as e:
    print(f"‚ùå Failed to send email: {e}")
    print("\nTroubleshooting steps:")
    print("1. Verify SES sender identity is verified in AWS console")
    print("2. Check AWS credentials (ACCESS_KEY_ID and SECRET_ACCESS_KEY)")
    print("3. Confirm DEFAULT_FROM_EMAIL matches verified identity")
    print("4. Check SES is out of sandbox mode (or recipient is verified)")
    print("5. Review CloudWatch logs for detailed error messages")
    sys.exit(1)
```

# ========================= OTHER FILES =========================


# ==== apps/ai/__init__.py ====

```python

```

# ==== apps/ai/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/ai/apps.py ====

```python
from django.apps import AppConfig


class AiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.ai'
```

# ==== apps/ai/migrations/__init__.py ====

```python

```

# ==== apps/ai/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/ai/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/ai/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/coverage/__init__.py ====

```python

```

# ==== apps/coverage/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/coverage/apps.py ====

```python
from django.apps import AppConfig


class CoverageConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.coverage'
```

# ==== apps/coverage/migrations/__init__.py ====

```python

```

# ==== apps/coverage/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/coverage/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/coverage/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/schedules/__init__.py ====

```python

```

# ==== apps/schedules/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/schedules/apps.py ====

```python
from django.apps import AppConfig


class SchedulesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.schedules'
```

# ==== apps/schedules/migrations/__init__.py ====

```python

```

# ==== apps/schedules/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/schedules/routing.py ====

```python
from django.urls import path

# Placeholder for WebSocket URL patterns
# We'll build this out in Phase 5 (WebSockets)
websocket_urlpatterns = [
    # path('ws/schedule/<int:period_id>/', ScheduleConsumer.as_asgi()),
]
    
```

# ==== apps/schedules/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/schedules/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/shifts/__init__.py ====

```python

```

# ==== apps/shifts/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/shifts/apps.py ====

```python
from django.apps import AppConfig


class ShiftsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.shifts'
```

# ==== apps/shifts/migrations/__init__.py ====

```python

```

# ==== apps/shifts/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/shifts/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/shifts/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/users/__init__.py ====

```python

```

# ==== apps/users/admin.py ====

```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User, EmailVerificationToken, PasswordResetToken


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    list_display = ['email', 'username', 'first_name', 'last_name', 'role', 'is_email_verified', 'is_active']
    list_filter = ['role', 'is_email_verified', 'is_active', 'date_joined']
    search_fields = ['email', 'username', 'first_name', 'last_name']
    ordering = ['-date_joined']
    
    fieldsets = (
        (None, {'fields': ('email', 'username', 'password')}),
        ('Personal Info', {'fields': ('first_name', 'last_name', 'phone_number')}),
        ('Permissions', {'fields': ('role', 'is_active', 'is_staff', 'is_superuser', 'is_email_verified')}),
        ('Important dates', {'fields': ('last_login', 'date_joined')}),
    )
    
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'username', 'password1', 'password2', 'first_name', 'last_name', 'phone_number', 'role'),
        }),
    )


@admin.register(EmailVerificationToken)
class EmailVerificationTokenAdmin(admin.ModelAdmin):
    list_display = ['user', 'token', 'created_at', 'expires_at', 'used']
    list_filter = ['used', 'created_at']
    search_fields = ['user__email', 'token']
    readonly_fields = ['token', 'created_at']


@admin.register(PasswordResetToken)
class PasswordResetTokenAdmin(admin.ModelAdmin):
    list_display = ['user', 'token', 'created_at', 'expires_at', 'used']
    list_filter = ['used', 'created_at']
    search_fields = ['user__email', 'token']
    readonly_fields = ['token', 'created_at']
```

# ==== apps/users/apps.py ====

```python
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.users'
```

# ==== apps/users/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 17:33

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('email', models.EmailField(db_index=True, max_length=254, unique=True)),
                ('phone_number', models.CharField(max_length=20)),
                ('role', models.CharField(choices=[('ADMIN', 'Admin'), ('PA', 'Personal Assistant')], default='PA', max_length=10)),
                ('is_email_verified', models.BooleanField(default=False)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'User',
                'verbose_name_plural': 'Users',
                'db_table': 'users',
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]
```

# ==== apps/users/migrations/0002_emailverificationtoken_passwordresettoken.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 18:04

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('users', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='EmailVerificationToken',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('token', models.UUIDField(default=uuid.uuid4, editable=False, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField()),
                ('used', models.BooleanField(default=False)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='verification_tokens', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'email_verification_tokens',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='PasswordResetToken',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('token', models.UUIDField(default=uuid.uuid4, editable=False, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField()),
                ('used', models.BooleanField(default=False)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='password_reset_tokens', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'password_reset_tokens',
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/users/migrations/__init__.py ====

```python

```

# ==== apps/users/models.py ====

```python
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils import timezone
import uuid
from datetime import timedelta


class User(AbstractUser):
    """
    Custom User model extending Django's AbstractUser.
    Email is the primary identifier instead of username.
    """
    email = models.EmailField(unique=True, db_index=True)
    phone_number = models.CharField(max_length=20)
    
    ROLE_CHOICES = [
        ('ADMIN', 'Admin'),
        ('PA', 'Personal Assistant'),
    ]
    role = models.CharField(max_length=10, choices=ROLE_CHOICES, default='PA')
    
    is_email_verified = models.BooleanField(default=False)
    
    # Make email the login field instead of username
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username', 'first_name', 'last_name']
    
    class Meta:
        db_table = 'users'
        verbose_name = 'User'
        verbose_name_plural = 'Users'
    
    def __str__(self):
        return f"{self.email} ({self.get_role_display()})"
    
    def save(self, *args, **kwargs):
        # Normalize email to lowercase
        if self.email:
            self.email = self.email.lower()
        super().save(*args, **kwargs)


class EmailVerificationToken(models.Model):
    """Token for email verification"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='verification_tokens')
    token = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    used = models.BooleanField(default=False)
    
    class Meta:
        db_table = 'email_verification_tokens'
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        if not self.expires_at:
            self.expires_at = timezone.now() + timedelta(days=7)
        super().save(*args, **kwargs)
    
    def is_valid(self):
        """Check if token is still valid"""
        return not self.used and timezone.now() < self.expires_at
    
    def __str__(self):
        return f"Verification token for {self.user.email}"


class PasswordResetToken(models.Model):
    """Token for password reset"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='password_reset_tokens')
    token = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    used = models.BooleanField(default=False)
    
    class Meta:
        db_table = 'password_reset_tokens'
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        if not self.expires_at:
            self.expires_at = timezone.now() + timedelta(hours=24)
        super().save(*args, **kwargs)
    
    def is_valid(self):
        """Check if token is still valid"""
        return not self.used and timezone.now() < self.expires_at
    
    def __str__(self):
        return f"Password reset token for {self.user.email}"
```

# ==== apps/users/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from .models import User


class UserSerializer(serializers.ModelSerializer):
    """Serializer for User responses"""
    class Meta:
        model = User
        fields = ['id', 'email', 'username', 'first_name', 'last_name', 
                  'phone_number', 'role', 'is_email_verified', 'date_joined']
        read_only_fields = ['id', 'date_joined', 'is_email_verified']


class RegisterSerializer(serializers.ModelSerializer):
    """Serializer for user registration"""
    password = serializers.CharField(
        write_only=True, 
        required=True, 
        validators=[validate_password],
        style={'input_type': 'password'}
    )
    password_confirm = serializers.CharField(
        write_only=True, 
        required=True,
        style={'input_type': 'password'}
    )

    class Meta:
        model = User
        fields = ['email', 'username', 'password', 'password_confirm', 
                  'first_name', 'last_name', 'phone_number']

    def validate_email(self, value):
        """Ensure email is lowercase and unique"""
        value = value.lower()
        if User.objects.filter(email=value).exists():
            raise serializers.ValidationError("A user with this email already exists.")
        return value

    def validate(self, attrs):
        """Check that passwords match"""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({
                "password": "Password fields didn't match."
            })
        return attrs

    def create(self, validated_data):
        """Create new user with hashed password"""
        validated_data.pop('password_confirm')
        user = User.objects.create_user(
            email=validated_data['email'],
            username=validated_data['username'],
            password=validated_data['password'],
            first_name=validated_data.get('first_name', ''),
            last_name=validated_data.get('last_name', ''),
            phone_number=validated_data['phone_number'],
            role='PA'  # Default role is PA
        )
        return user


class LoginSerializer(serializers.Serializer):
    """Serializer for user login"""
    email = serializers.EmailField()
    password = serializers.CharField(
        write_only=True,
        style={'input_type': 'password'}
    )

    def validate_email(self, value):
        """Normalize email to lowercase"""
        return value.lower()

    def validate(self, attrs):
        """Authenticate user"""
        email = attrs.get('email')
        password = attrs.get('password')

        if email and password:
            # Try to authenticate
            user = authenticate(
                request=self.context.get('request'),
                username=email,  # We use email as username
                password=password
            )

            if not user:
                raise serializers.ValidationError(
                    'Unable to log in with provided credentials.',
                    code='authorization'
                )
            
            if not user.is_active:
                raise serializers.ValidationError(
                    'User account is disabled.',
                    code='authorization'
                )

            attrs['user'] = user
            return attrs
        else:
            raise serializers.ValidationError(
                'Must include "email" and "password".',
                code='authorization'
            )


class PasswordResetRequestSerializer(serializers.Serializer):
    """Serializer for requesting password reset"""
    email = serializers.EmailField()

    def validate_email(self, value):
        """Normalize email to lowercase"""
        return value.lower()


class PasswordResetConfirmSerializer(serializers.Serializer):
    """Serializer for confirming password reset"""
    token = serializers.UUIDField()
    password = serializers.CharField(
        write_only=True,
        required=True,
        validators=[validate_password],
        style={'input_type': 'password'}
    )
    password_confirm = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )

    def validate(self, attrs):
        """Check that passwords match"""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({
                "password": "Password fields didn't match."
            })
        return attrs


class EmailVerificationSerializer(serializers.Serializer):
    """Serializer for email verification"""
    token = serializers.UUIDField()


class UserProfileUpdateSerializer(serializers.ModelSerializer):
    """Serializer for updating user profile"""
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'phone_number']

    def validate_phone_number(self, value):
        """Ensure phone number is provided"""
        if not value:
            raise serializers.ValidationError("Phone number is required.")
        return value
```

# ==== apps/users/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/users/urls.py ====

```python
from django.urls import path
from .views import (
    RegisterView,
    VerifyEmailView,
    LoginView,
    RefreshTokenView,
    LogoutView,
    PasswordResetRequestView,
    PasswordResetConfirmView,
    UserProfileView,
)

app_name = 'users'

urlpatterns = [
    # Authentication
    path('register/', RegisterView.as_view(), name='register'),
    path('verify-email/', VerifyEmailView.as_view(), name='verify-email'),
    path('login/', LoginView.as_view(), name='login'),
    path('refresh/', RefreshTokenView.as_view(), name='refresh'),
    path('logout/', LogoutView.as_view(), name='logout'),
    
    # Password Reset
    path('password-reset/', PasswordResetRequestView.as_view(), name='password-reset'),
    path('password-reset-confirm/', PasswordResetConfirmView.as_view(), name='password-reset-confirm'),
    
    # Profile
    path('me/', UserProfileView.as_view(), name='user-profile'),
]
```

# ==== apps/users/views.py ====

```python
from rest_framework import status, generics, permissions
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import get_user_model
from django.shortcuts import get_object_or_404

from .serializers import (
    UserSerializer, 
    RegisterSerializer, 
    LoginSerializer,
    PasswordResetRequestSerializer,
    PasswordResetConfirmSerializer,
    EmailVerificationSerializer,
    UserProfileUpdateSerializer
)
from .models import EmailVerificationToken, PasswordResetToken

User = get_user_model()


class RegisterView(generics.CreateAPIView):
    """
    POST: Register a new PA user
    Creates user and sends verification email
    """
    queryset = User.objects.all()
    serializer_class = RegisterSerializer
    permission_classes = [permissions.AllowAny]

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        
        # Create verification token
        token = EmailVerificationToken.objects.create(user=user)
        
        # TODO: Send verification email (Task 1.3)
        # send_verification_email(user, token)
        
        return Response({
            'message': 'Registration successful. Please check your email to verify your account.',
            'user': UserSerializer(user).data,
            'verification_token': str(token.token)  # Remove in production
        }, status=status.HTTP_201_CREATED)


class VerifyEmailView(APIView):
    """
    POST: Verify email with token
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = EmailVerificationSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        token_uuid = serializer.validated_data['token']
        
        try:
            token = EmailVerificationToken.objects.get(token=token_uuid)
        except EmailVerificationToken.DoesNotExist:
            return Response(
                {'error': 'Invalid verification token.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if not token.is_valid():
            return Response(
                {'error': 'Verification token has expired or been used.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Mark token as used and verify user
        token.used = True
        token.save()
        
        user = token.user
        user.is_email_verified = True
        user.save()
        
        return Response({
            'message': 'Email verified successfully. You can now log in.',
            'user': UserSerializer(user).data
        }, status=status.HTTP_200_OK)


class LoginView(APIView):
    """
    POST: Login with email and password
    Returns JWT access and refresh tokens
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = LoginSerializer(data=request.data, context={'request': request})
        serializer.is_valid(raise_exception=True)
        
        user = serializer.validated_data['user']
        
        # Generate JWT tokens
        refresh = RefreshToken.for_user(user)
        
        return Response({
            'message': 'Login successful.',
            'user': UserSerializer(user).data,
            'tokens': {
                'refresh': str(refresh),
                'access': str(refresh.access_token),
            }
        }, status=status.HTTP_200_OK)


class RefreshTokenView(APIView):
    """
    POST: Refresh access token using refresh token
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        refresh_token = request.data.get('refresh')
        
        if not refresh_token:
            return Response(
                {'error': 'Refresh token is required.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            refresh = RefreshToken(refresh_token)
            return Response({
                'access': str(refresh.access_token)
            }, status=status.HTTP_200_OK)
        except Exception as e:
            return Response(
                {'error': 'Invalid or expired refresh token.'},
                status=status.HTTP_401_UNAUTHORIZED
            )


class LogoutView(APIView):
    """
    POST: Logout (blacklist refresh token)
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        try:
            refresh_token = request.data.get('refresh')
            if refresh_token:
                token = RefreshToken(refresh_token)
                token.blacklist()
            return Response(
                {'message': 'Logout successful.'},
                status=status.HTTP_200_OK
            )
        except Exception:
            return Response(
                {'error': 'Invalid token.'},
                status=status.HTTP_400_BAD_REQUEST
            )


class PasswordResetRequestView(APIView):
    """
    POST: Request password reset email
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PasswordResetRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        email = serializer.validated_data['email']
        
        try:
            user = User.objects.get(email=email)
            
            # Create reset token
            token = PasswordResetToken.objects.create(user=user)
            
            # TODO: Send reset email (Task 1.3)
            # send_password_reset_email(user, token)
            
            return Response({
                'message': 'Password reset email sent. Please check your email.',
                'reset_token': str(token.token)  # Remove in production
            }, status=status.HTTP_200_OK)
        except User.DoesNotExist:
            # Don't reveal if email exists
            return Response({
                'message': 'If that email exists, a password reset link has been sent.'
            }, status=status.HTTP_200_OK)


class PasswordResetConfirmView(APIView):
    """
    POST: Reset password with token
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PasswordResetConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        token_uuid = serializer.validated_data['token']
        new_password = serializer.validated_data['password']
        
        try:
            token = PasswordResetToken.objects.get(token=token_uuid)
        except PasswordResetToken.DoesNotExist:
            return Response(
                {'error': 'Invalid reset token.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if not token.is_valid():
            return Response(
                {'error': 'Reset token has expired or been used.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Reset password
        user = token.user
        user.set_password(new_password)
        user.save()
        
        # Mark token as used
        token.used = True
        token.save()
        
        return Response({
            'message': 'Password reset successful. You can now log in with your new password.'
        }, status=status.HTTP_200_OK)


class UserProfileView(generics.RetrieveUpdateAPIView):
    """
    GET: Get current user profile
    PATCH: Update current user profile
    """
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_object(self):
        return self.request.user
    
    def get_serializer_class(self):
        if self.request.method == 'PATCH':
            return UserProfileUpdateSerializer
        return UserSerializer
```

