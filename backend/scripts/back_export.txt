# TOTETAXI - BACKEND CODE SNAPSHOT
# AUTO-GENERATED - CODE FILES ONLY
# Created: 2025-10-31 18:47:44
# Total files: 68
# 🔒 SECURITY: .env files excluded (contain secrets)
# 📋 INCLUDES: All Django apps, migrations, configuration
# Apps: accounts (STAFF), bookings, customers, logistics, payments, services
# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery
# Integration: S3 storage, SES email, mocked Stripe/Onfleet


# ========================= CONFIGURATION & ROOT FILES =========================


# ==== .dockerignore ====

```
# Git
.git
.gitignore

# Docker
.docker
Dockerfile
Dockerfile.prod
docker-compose*

# Python
__pycache__
*.pyc
*.pyo
*.pyd
.Python
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.pytest_cache
.cache
htmlcov
.mypy_cache
.dmypy.json
dmypy.json

# IDEs
.vscode
.idea
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log
npm-debug.log*

# Environment
.env
.env.local
.env.development
.env.production

# Database
*.sqlite3
db.sqlite3

# Media files
media/

# Static files (will be collected in container)
staticfiles/

# Node (if any)
node_modules
npm-debug.log
```

# ==== Dockerfile ====

```dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app \
    PORT=8000

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        postgresql-client \
        build-essential \
        libpq-dev \
        curl \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . /app/

# Create directories for logs and static files
RUN mkdir -p /app/logs /app/staticfiles /app/media

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD curl -f http://localhost:8000/ || exit 1

CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
```

# ==== docker-compose.yml ====

```yaml
name: pa-scheduler-backend

services:
  # PostgreSQL Database - PORT 5436
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: pa_scheduler
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5436:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis for Celery - PORT 6383
  redis:
    image: redis:7-alpine
    ports:
      - "6383:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Django Backend - PORT 8006
  web:
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    ports:
      - "8006:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/pa_scheduler
      - REDIS_URL=redis://redis:6379/0

  # Celery Worker
  celery:
    build: .
    command: celery -A config worker -l info
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/pa_scheduler
      - REDIS_URL=redis://redis:6379/0

  # Celery Beat Scheduler
  celery-beat:
    build: .
    command: celery -A config beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/pa_scheduler
      - REDIS_URL=redis://redis:6379/0

volumes:
  postgres_data:
  static_volume:
  media_volume:
  redis_data:
```

# ==== manage.py ====

```python
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```

# ==== requirements.txt ====

```
# Django Core - Django 5.2 LTS
Django==5.2.7
djangorestframework==3.16.1
django-cors-headers==4.6.0

# Database
psycopg2-binary==2.9.10
dj-database-url==2.2.0

# Authentication
djangorestframework-simplejwt==5.4.0

# Async Tasks
celery==5.5.3
redis==5.2.0
django-celery-beat==2.8.0

# WebSockets
channels==4.3.1
channels-redis==4.2.1
daphne==4.2.1

# Email
boto3==1.35.80

# AI
openai==2.6.1

# Server
gunicorn==23.0.0

# Utilities
python-dotenv==1.0.1
Pillow==11.0.0
```

# ========================= DJANGO PROJECT SETTINGS (config/) =========================


# ==== config/__init__.py ====

```python
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)
```

# ==== config/asgi.py ====

```python
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

django_asgi_app = get_asgi_application()

# Import after Django is set up
from apps.schedules.routing import websocket_urlpatterns

application = ProtocolTypeRouter({
    "http": django_asgi_app,
    "websocket": AuthMiddlewareStack(
        URLRouter(
            websocket_urlpatterns
        )
    ),
})
```

# ==== config/celery.py ====

```python
import os
from celery import Celery
from celery.schedules import crontab

# Set the default Django settings module
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

app = Celery('config')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django apps.
app.autodiscover_tasks()

# Celery Beat Schedule
app.conf.beat_schedule = {
    'check-upcoming-coverage': {
        'task': 'apps.ai.tasks.check_upcoming_coverage',
        'schedule': crontab(hour=6, minute=0),  # Run daily at 6 AM
    },
    'calculate-pa-patterns': {
        'task': 'apps.users.tasks.calculate_all_pa_patterns',
        'schedule': crontab(day_of_week=1, hour=2, minute=0),  # Run weekly Monday 2 AM
    },
}

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
```

# ==== config/settings.py ====

```python
import os
from pathlib import Path
from datetime import timedelta
import dj_database_url

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.environ.get('SECRET_KEY', 'django-insecure-dev-key-change-this-in-production')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.environ.get('DEBUG', 'True') == 'True'

ALLOWED_HOSTS = os.environ.get('ALLOWED_HOSTS', 'localhost,127.0.0.1').split(',')

# Application definition
INSTALLED_APPS = [
    'daphne',  # Must be first for channels
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third-party apps
    'rest_framework',
    'rest_framework_simplejwt',
    'rest_framework_simplejwt.token_blacklist',  # Add this line
    'corsheaders',
    'channels',
    'django_celery_beat',
    
    # Local apps
    'apps.users',
    'apps.schedules',
    'apps.shifts',
    'apps.coverage',
    'apps.ai',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'
ASGI_APPLICATION = 'config.asgi.application'

# Database
DATABASES = {
    'default': dj_database_url.config(
        default=os.environ.get('DATABASE_URL', 'postgres://postgres:postgres@localhost:5436/pa_scheduler'),
        conn_max_age=600
    )
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Custom User Model
AUTH_USER_MODEL = 'users.User'

# REST Framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 50,
}

# JWT Settings
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': True,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
}

# Add to INSTALLED_APPS

# CORS Settings
CORS_ALLOWED_ORIGINS = os.environ.get(
    'CORS_ALLOWED_ORIGINS',
    'http://localhost:3000'
).split(',')

CORS_ALLOW_CREDENTIALS = True

# Celery Configuration
CELERY_BROKER_URL = os.environ.get('REDIS_URL', 'redis://localhost:6383/0')
CELERY_RESULT_BACKEND = os.environ.get('REDIS_URL', 'redis://localhost:6383/0')
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE

# Channels (WebSockets)
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            'hosts': [os.environ.get('REDIS_URL', 'redis://localhost:6383/0')],
        },
    },
}

# Email Configuration (Amazon SES)
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend' if not DEBUG else 'django.core.mail.backends.console.EmailBackend'
EMAIL_HOST = 'email-smtp.us-east-1.amazonaws.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = os.environ.get('AWS_ACCESS_KEY_ID', '')
EMAIL_HOST_PASSWORD = os.environ.get('AWS_SECRET_ACCESS_KEY', '')
DEFAULT_FROM_EMAIL = os.environ.get('DEFAULT_FROM_EMAIL', 'noreply@example.com')

# OpenAI
OPENAI_API_KEY = os.environ.get('OPENAI_API_KEY', '')

# Frontend URL
FRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')
# Logging

# Ensure logs directory exists
LOGS_DIR = BASE_DIR / 'logs'
LOGS_DIR.mkdir(exist_ok=True)

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': LOGS_DIR / 'django.log',
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': os.environ.get('DJANGO_LOG_LEVEL', 'INFO'),
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
```

# ==== config/urls.py ====

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/auth/', include('apps.users.urls')),
    path('api/', include('apps.schedules.urls')),
    path('api/', include('apps.shifts.urls')),
]
```

# ==== config/wsgi.py ====

```python
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
```

# ========================= SCRIPTS & UTILITIES =========================


# ==== scripts/back_export.py ====

```python
#!/usr/bin/env python3
"""
ToteTaxi Backend Export - Code Files Only
"""
import os
from pathlib import Path
from datetime import datetime

def get_file_content(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"# Error reading file: {e}"

def should_include_file(file_path, base_dir):
    """Smart file inclusion rules for ToteTaxi Backend - Code Only"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Skip patterns - SECURITY: Handle .env files separately
    skip_patterns = [
        '__pycache__', '.pyc', '.git/', '.pytest_cache/', 'htmlcov/',
        'staticfiles/', 'media/', 'logs/', '.coverage', 'db.sqlite3',
        'back_export.txt', 'totetaxi_backend_snapshot.txt',
        '.DS_Store', '*.swp', '*.swo',
        'README.md', 'CHANGELOG.md'  # Skip documentation files
    ]
    
    if any(pattern in path_str for pattern in skip_patterns):
        return False
    
    # SECURITY: Skip .env files (contain secrets)
    if file_path.name.startswith('.env'):
        return False
    
    # Include patterns - Code files only
    include_extensions = {'.py', '.txt', '.yml', '.yaml', '.toml', '.sh', '.ini', '.conf'}
    include_files = {
        'Dockerfile', 'Dockerfile.dev', '.dockerignore', '.gitignore', 
        'manage.py', 'docker-compose.yml', 'docker-compose.prod.yml',
        'gunicorn.conf.py', 'pytest.ini', 'requirements.txt'
    }
    
    return (
        file_path.suffix in include_extensions or 
        file_path.name in include_files
    )

def categorize_file(file_path, base_dir):
    """Auto-categorize files for ToteTaxi structure"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Configuration files (root level)
    if (rel_path.parent == Path('.') or 
        file_path.name in ['manage.py', 'requirements.txt', 'gunicorn.conf.py', 'pytest.ini']):
        return 'config'
    
    # ToteTaxi Django apps - UPDATED to 6 apps only
    totetaxi_apps = [
        'accounts/', 'bookings/', 'customers/', 
        'logistics/', 'payments/', 'services/'
    ]
    if any(f'apps/{app}' in path_str for app in totetaxi_apps):
        return 'apps'
    
    # Django project settings (config/ directory)
    if 'config/' in path_str:
        return 'project'
    
    # Scripts directory
    if 'scripts/' in path_str:
        return 'scripts'
    
    # Everything else
    return 'other'

def main():
    backend_dir = Path(__file__).parent.parent
    output_file = backend_dir / 'scripts' / 'back_export.txt'
    
    print(f"🔍 Auto-discovering ToteTaxi backend files in: {backend_dir}")
    
    # Auto-discover all relevant files
    all_files = []
    for file_path in backend_dir.rglob('*'):
        if file_path.is_file() and should_include_file(file_path, backend_dir):
            all_files.append(file_path)
    
    # Categorize files
    categories = {
        'config': [],
        'project': [],
        'apps': [],
        'scripts': [],
        'other': []
    }
    
    for file_path in all_files:
        category = categorize_file(file_path, backend_dir)
        categories[category].append(file_path)
    
    # Sort within categories
    for category in categories:
        categories[category].sort()
    
    print(f"📊 Found {len(all_files)} files:")
    for cat, files in categories.items():
        if files:
            print(f"  - {cat}: {len(files)} files")
    
    # Generate snapshot
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# TOTETAXI - BACKEND CODE SNAPSHOT\n")
        f.write("# AUTO-GENERATED - CODE FILES ONLY\n")
        f.write(f"# Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# Total files: {len(all_files)}\n")
        f.write("# 🔒 SECURITY: .env files excluded (contain secrets)\n")
        f.write("# 📋 INCLUDES: All Django apps, migrations, configuration\n")
        f.write("# Apps: accounts (STAFF), bookings, customers, logistics, payments, services\n")  # UPDATED
        f.write("# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery\n")
        f.write("# Integration: S3 storage, SES email, mocked Stripe/Onfleet\n\n\n")
        
        # Output by category
        section_names = {
            'config': 'CONFIGURATION & ROOT FILES',
            'project': 'DJANGO PROJECT SETTINGS (config/)',
            'apps': 'DJANGO APPLICATIONS (apps/)',
            'scripts': 'SCRIPTS & UTILITIES',
            'other': 'OTHER FILES'
        }
        
        for category, section_name in section_names.items():
            if categories[category]:
                f.write("# " + "="*25 + f" {section_name} " + "="*25 + "\n\n\n")
                
                for file_path in categories[category]:
                    rel_path = file_path.relative_to(backend_dir)
                    f.write(f"# ==== {rel_path} ====\n\n")
                    
                    # Smart syntax highlighting
                    if file_path.suffix == '.py':
                        f.write("```python\n")
                    elif file_path.suffix in ['.yml', '.yaml']:
                        f.write("```yaml\n")
                    elif file_path.suffix == '.toml':
                        f.write("```toml\n")
                    elif file_path.suffix == '.sh':
                        f.write("```bash\n")
                    elif file_path.name in ['Dockerfile', 'Dockerfile.dev']:
                        f.write("```dockerfile\n")
                    elif file_path.suffix == '.ini':
                        f.write("```ini\n")
                    else:
                        f.write("```\n")
                    
                    content = get_file_content(file_path)
                    f.write(content)
                    if not content.endswith('\n'):
                        f.write('\n')
                    f.write("```\n\n")
    
    print(f"✅ Auto-generated ToteTaxi backend snapshot: {output_file}")
    print("🔒 SECURITY: .env files excluded (contain secrets)")
    print("📋 INCLUDES: All 6 Django apps with migrations")  # UPDATED
    print("🏗️  STRUCTURE: accounts (staff), bookings, customers, logistics, payments, services")  # UPDATED
    print("🐳 DOCKER: Configuration and compose files included")
    print("📁 CODE ONLY: Documentation files excluded")

if __name__ == "__main__":
    main()
```

# ==== scripts/entrypoint.sh ====

```bash
#!/bin/bash
set -e

echo "Starting ToteTaxi Backend..."

# CRITICAL FIX: Unset docker-compose DB variables on Fly.io
unset DB_HOST
unset DB_NAME
unset DB_USER
unset DB_PASSWORD
unset DB_PORT

# Wait for database if DB_HOST is set (won't happen after unset)
if [ -n "$DB_HOST" ]; then
    echo "Waiting for postgres at $DB_HOST:${DB_PORT:-5432}..."
    while ! pg_isready -h "$DB_HOST" -p "${DB_PORT:-5432}" -U "${DB_USER:-postgres}"; do
      sleep 1
    done
    echo "PostgreSQL is ready!"
fi

# Run migrations
echo "Running database migrations..."
python manage.py migrate --no-input

# Collect static files (in case not done in Dockerfile)
echo "Collecting static files..."
python manage.py collectstatic --no-input --clear || true

# Create cache table if needed
python manage.py createcachetable || true

# Create superuser if specified (optional)
if [ -n "$DJANGO_SUPERUSER_EMAIL" ] && [ -n "$DJANGO_SUPERUSER_PASSWORD" ]; then
    echo "Creating superuser..."
    python manage.py shell -c "
from django.contrib.auth import get_user_model
User = get_user_model()
if not User.objects.filter(email='$DJANGO_SUPERUSER_EMAIL').exists():
    User.objects.create_superuser('$DJANGO_SUPERUSER_EMAIL', '$DJANGO_SUPERUSER_EMAIL', '$DJANGO_SUPERUSER_PASSWORD')
    print('Superuser created')
else:
    print('Superuser already exists')
" || true
fi

echo "Starting application..."
exec "$@"
```

# ==== scripts/validate_ses_setup.py ====

```python
# backend/scripts/validate_ses_setup.py
"""
Validate SES setup for production
Run locally: docker-compose exec web python manage.py shell < scripts/validate_ses_setup.py
Run on Fly.io: fly ssh console -a totetaxi-backend -C "python manage.py shell < scripts/validate_ses_setup.py"
"""
import sys
from django.core.mail import send_mail
from django.conf import settings

print("🔍 Validating SES Configuration...")
print(f"EMAIL_BACKEND: {settings.EMAIL_BACKEND}")
print(f"EMAIL_HOST: {settings.EMAIL_HOST}")
print(f"EMAIL_PORT: {settings.EMAIL_PORT}")
print(f"EMAIL_USE_TLS: {settings.EMAIL_USE_TLS}")
print(f"DEFAULT_FROM_EMAIL: {settings.DEFAULT_FROM_EMAIL}")

# Check if using SES in production
if 'ses' not in settings.EMAIL_BACKEND.lower() and not settings.DEBUG:
    print("⚠️  WARNING: Not using SES backend in production!")
    print(f"Current backend: {settings.EMAIL_BACKEND}")
    sys.exit(1)

# In local dev, skip SES validation
if settings.DEBUG and 'console' in settings.EMAIL_BACKEND.lower():
    print("ℹ️  Running in DEBUG mode with console backend - SES validation skipped")
    print("✅ Email configuration is correct for local development")
    sys.exit(0)

print("\n📧 Sending test email to mnraynor90@gmail.com...")
try:
    send_mail(
        subject='ToteTaxi SES Test - Production Email Validation',
        message='''This is a test email from ToteTaxi to validate SES setup.

If you received this email, your SES configuration is working correctly!

Test Details:
- Backend: {backend}
- From: {from_email}
- Host: {host}
- Port: {port}

Next steps:
1. Check AWS SES dashboard for delivery metrics
2. Verify email templates are rendering correctly
3. Test all email types (welcome, verification, password reset, bookings)

ToteTaxi Backend Team
'''.format(
            backend=settings.EMAIL_BACKEND,
            from_email=settings.DEFAULT_FROM_EMAIL,
            host=settings.EMAIL_HOST,
            port=settings.EMAIL_PORT
        ),
        from_email=settings.DEFAULT_FROM_EMAIL,
        recipient_list=['mnraynor90@gmail.com'],
        fail_silently=False,
    )
    print("✅ Test email sent successfully!")
    print("📬 Check mnraynor90@gmail.com inbox to confirm delivery.")
    print("\n✨ SES validation complete!")
except Exception as e:
    print(f"❌ Failed to send email: {e}")
    print("\nTroubleshooting steps:")
    print("1. Verify SES sender identity is verified in AWS console")
    print("2. Check AWS credentials (ACCESS_KEY_ID and SECRET_ACCESS_KEY)")
    print("3. Confirm DEFAULT_FROM_EMAIL matches verified identity")
    print("4. Check SES is out of sandbox mode (or recipient is verified)")
    print("5. Review CloudWatch logs for detailed error messages")
    sys.exit(1)
```

# ========================= OTHER FILES =========================


# ==== apps/ai/__init__.py ====

```python

```

# ==== apps/ai/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/ai/apps.py ====

```python
from django.apps import AppConfig


class AiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.ai'
```

# ==== apps/ai/migrations/__init__.py ====

```python

```

# ==== apps/ai/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/ai/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/ai/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/coverage/__init__.py ====

```python

```

# ==== apps/coverage/admin.py ====

```python
from django.contrib import admin
from .models import CriticalTimeCoverage, WeeklyCoverage


@admin.register(CriticalTimeCoverage)
class CriticalTimeCoverageAdmin(admin.ModelAdmin):
    list_display = ['date', 'morning_covered', 'evening_covered', 'coverage_status', 'updated_at']
    list_filter = ['morning_covered', 'evening_covered', 'date']
    search_fields = ['date']
    readonly_fields = ['updated_at']
    date_hierarchy = 'date'
    
    fieldsets = (
        ('Date', {
            'fields': ('date',)
        }),
        ('Coverage Status', {
            'fields': ('morning_covered', 'evening_covered', 'morning_shift', 'evening_shift')
        }),
        ('Metadata', {
            'fields': ('updated_at',),
            'classes': ('collapse',)
        }),
    )
    
    def coverage_status(self, obj):
        """Display coverage status with icon"""
        if obj.is_fully_covered:
            return '✅ Complete'
        elif obj.morning_covered or obj.evening_covered:
            return '⚠️ Partial'
        return '❌ None'
    coverage_status.short_description = 'Coverage Status'


@admin.register(WeeklyCoverage)
class WeeklyCoverageAdmin(admin.ModelAdmin):
    list_display = ['pa', 'week_start_date', 'schedule_period', 'total_hours', 'exceeds_limit', 'updated_at']
    list_filter = ['exceeds_limit', 'schedule_period', 'week_start_date']
    search_fields = ['pa__email', 'pa__first_name', 'pa__last_name']
    readonly_fields = ['updated_at']
    date_hierarchy = 'week_start_date'
    
    fieldsets = (
        ('Week Information', {
            'fields': ('schedule_period', 'pa', 'week_start_date')
        }),
        ('Hours', {
            'fields': ('total_hours', 'exceeds_limit')
        }),
        ('Metadata', {
            'fields': ('updated_at',),
            'classes': ('collapse',)
        }),
    )
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related(
            'schedule_period', 'pa'
        )
```

# ==== apps/coverage/apps.py ====

```python
from django.apps import AppConfig


class CoverageConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.coverage'
```

# ==== apps/coverage/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 18:20

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('schedules', '0001_initial'),
        ('shifts', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CriticalTimeCoverage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField(db_index=True, unique=True)),
                ('morning_covered', models.BooleanField(default=False)),
                ('evening_covered', models.BooleanField(default=False)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('evening_shift', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='covers_evening', to='shifts.shiftrequest')),
                ('morning_shift', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='covers_morning', to='shifts.shiftrequest')),
            ],
            options={
                'verbose_name': 'Critical Time Coverage',
                'verbose_name_plural': 'Critical Time Coverage',
                'db_table': 'critical_time_coverage',
                'ordering': ['date'],
            },
        ),
        migrations.CreateModel(
            name='WeeklyCoverage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('week_start_date', models.DateField(db_index=True)),
                ('total_hours', models.DecimalField(decimal_places=2, default=0, max_digits=5)),
                ('exceeds_limit', models.BooleanField(default=False)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('pa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='weekly_hours', to=settings.AUTH_USER_MODEL)),
                ('schedule_period', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='weekly_coverage', to='schedules.scheduleperiod')),
            ],
            options={
                'verbose_name': 'Weekly Coverage',
                'verbose_name_plural': 'Weekly Coverage',
                'db_table': 'weekly_coverage',
                'ordering': ['week_start_date', 'pa'],
                'unique_together': {('schedule_period', 'pa', 'week_start_date')},
            },
        ),
    ]
```

# ==== apps/coverage/migrations/__init__.py ====

```python

```

# ==== apps/coverage/models.py ====

```python
# apps/coverage/models.py
from django.db import models
from django.conf import settings


class CriticalTimeCoverage(models.Model):
    """
    Tracks whether critical times (6-9 AM morning, 9-10 PM evening) are covered for each date.
    Updated automatically when shifts are approved/rejected/deleted.
    """
    date = models.DateField(unique=True, db_index=True)
    morning_covered = models.BooleanField(default=False)  # 6-9 AM
    evening_covered = models.BooleanField(default=False)  # 9-10 PM
    morning_shift = models.ForeignKey(
        'shifts.ShiftRequest', 
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='covers_morning'
    )
    evening_shift = models.ForeignKey(
        'shifts.ShiftRequest',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='covers_evening'
    )
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'critical_time_coverage'
        ordering = ['date']
        verbose_name = 'Critical Time Coverage'
        verbose_name_plural = 'Critical Time Coverage'
    
    def __str__(self):
        status = []
        if self.morning_covered:
            status.append('Morning ✅')
        else:
            status.append('Morning ❌')
        if self.evening_covered:
            status.append('Evening ✅')
        else:
            status.append('Evening ❌')
        return f"{self.date} - {' | '.join(status)}"
    
    @property
    def is_fully_covered(self):
        """Returns True if both morning and evening are covered"""
        return self.morning_covered and self.evening_covered
    
    @property
    def coverage_status(self):
        """Returns coverage status: 'complete', 'partial', or 'none'"""
        if self.morning_covered and self.evening_covered:
            return 'complete'
        elif self.morning_covered or self.evening_covered:
            return 'partial'
        return 'none'


class WeeklyCoverage(models.Model):
    """
    Tracks total hours worked by each PA per week within a schedule period.
    Used for overtime warnings and weekly limit checks.
    """
    schedule_period = models.ForeignKey(
        'schedules.SchedulePeriod', 
        on_delete=models.CASCADE,
        related_name='weekly_coverage'
    )
    pa = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE,
        related_name='weekly_hours'
    )
    week_start_date = models.DateField(db_index=True)  # Monday of the week
    total_hours = models.DecimalField(max_digits=5, decimal_places=2, default=0)
    exceeds_limit = models.BooleanField(default=False)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'weekly_coverage'
        unique_together = ['schedule_period', 'pa', 'week_start_date']
        ordering = ['week_start_date', 'pa']
        verbose_name = 'Weekly Coverage'
        verbose_name_plural = 'Weekly Coverage'
    
    def __str__(self):
        warning = " ⚠️ OVERTIME" if self.exceeds_limit else ""
        return f"{self.pa.get_full_name()} - Week of {self.week_start_date}: {self.total_hours}h{warning}"
    
    def check_exceeds_limit(self, max_hours=40):
        """
        Check if total hours exceed the limit.
        max_hours can be passed from PA's custom limit or default 40.
        """
        self.exceeds_limit = self.total_hours > max_hours
        return self.exceeds_limit
```

# ==== apps/coverage/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/coverage/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/schedules/__init__.py ====

```python

```

# ==== apps/schedules/admin.py ====

```python
from django.contrib import admin
from .models import SchedulePeriod


@admin.register(SchedulePeriod)
class SchedulePeriodAdmin(admin.ModelAdmin):
    list_display = ['name', 'start_date', 'end_date', 'status', 'created_by', 'created_at']
    list_filter = ['status', 'created_at']
    search_fields = ['name']
    readonly_fields = ['created_at', 'updated_at']
    
    fieldsets = (
        ('Period Information', {
            'fields': ('name', 'start_date', 'end_date', 'status')
        }),
        ('Metadata', {
            'fields': ('created_by', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
```

# ==== apps/schedules/apps.py ====

```python
from django.apps import AppConfig


class SchedulesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.schedules'
```

# ==== apps/schedules/consumers.py ====

```python
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth.models import AnonymousUser
from rest_framework_simplejwt.tokens import AccessToken
from rest_framework_simplejwt.exceptions import InvalidToken, TokenError
from apps.users.models import User


class ScheduleConsumer(AsyncWebsocketConsumer):
    """
    WebSocket consumer for real-time schedule updates.
    
    URL: ws://localhost:8006/ws/schedule/<period_id>/
    
    Events broadcast to this consumer:
    - shift.requested (new shift request submitted)
    - shift.approved (shift approved)
    - shift.rejected (shift rejected)
    - shift.updated (shift edited)
    - shift.deleted (shift deleted)
    - coverage.alert (coverage status changed)
    - period.finalized (period finalized)
    """
    
    async def connect(self):
        """Handle WebSocket connection"""
        self.period_id = self.scope['url_route']['kwargs']['period_id']
        self.room_group_name = f'schedule_{self.period_id}'
        
        # Authenticate user via JWT token
        user = await self.get_user_from_token()
        
        if user is None or user.is_anonymous:
            # Reject connection if not authenticated
            await self.close(code=4001)
            return
        
        self.scope['user'] = user
        
        # Join room group
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # Send connection confirmation
        await self.send(text_data=json.dumps({
            'type': 'connection.established',
            'message': f'Connected to schedule period {self.period_id}',
            'user': {
                'id': user.id,
                'email': user.email,
                'role': user.role
            }
        }))
    
    async def disconnect(self, close_code):
        """Handle WebSocket disconnection"""
        # Leave room group
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
    
    async def receive(self, text_data):
        """
        Receive message from WebSocket (client -> server)
        Currently not used, but available for future bidirectional features
        """
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            
            # Handle ping/pong for connection keep-alive
            if message_type == 'ping':
                await self.send(text_data=json.dumps({
                    'type': 'pong',
                    'timestamp': data.get('timestamp')
                }))
        except json.JSONDecodeError:
            await self.send(text_data=json.dumps({
                'type': 'error',
                'message': 'Invalid JSON'
            }))
    
    # Event handlers (server -> client broadcasts)
    
    async def shift_requested(self, event):
        """Broadcast when a new shift is requested"""
        await self.send(text_data=json.dumps({
            'type': 'shift.requested',
            'shift': event['shift'],
            'message': event.get('message', 'New shift request submitted')
        }))
    
    async def shift_approved(self, event):
        """Broadcast when a shift is approved"""
        await self.send(text_data=json.dumps({
            'type': 'shift.approved',
            'shift': event['shift'],
            'message': event.get('message', 'Shift approved')
        }))
    
    async def shift_rejected(self, event):
        """Broadcast when a shift is rejected"""
        await self.send(text_data=json.dumps({
            'type': 'shift.rejected',
            'shift': event['shift'],
            'message': event.get('message', 'Shift rejected')
        }))
    
    async def shift_updated(self, event):
        """Broadcast when a shift is updated"""
        await self.send(text_data=json.dumps({
            'type': 'shift.updated',
            'shift': event['shift'],
            'changes': event.get('changes', {}),
            'message': event.get('message', 'Shift updated')
        }))
    
    async def shift_deleted(self, event):
        """Broadcast when a shift is deleted"""
        await self.send(text_data=json.dumps({
            'type': 'shift.deleted',
            'shift_id': event['shift_id'],
            'message': event.get('message', 'Shift deleted')
        }))
    
    async def coverage_alert(self, event):
        """Broadcast when coverage status changes"""
        await self.send(text_data=json.dumps({
            'type': 'coverage.alert',
            'date': event['date'],
            'coverage': event['coverage'],
            'message': event.get('message', 'Coverage updated')
        }))
    
    async def period_finalized(self, event):
        """Broadcast when period is finalized"""
        await self.send(text_data=json.dumps({
            'type': 'period.finalized',
            'period': event['period'],
            'message': event.get('message', 'Schedule period finalized')
        }))
    
    # Helper methods
    
    @database_sync_to_async
    def get_user_from_token(self):
        """
        Authenticate user from JWT token in query string.
        WebSocket URL: ws://localhost:8006/ws/schedule/1/?token=<jwt_token>
        """
        try:
            # Get token from query string
            query_string = self.scope.get('query_string', b'').decode()
            params = dict(param.split('=') for param in query_string.split('&') if '=' in param)
            token = params.get('token')
            
            if not token:
                return AnonymousUser()
            
            # Validate token
            access_token = AccessToken(token)
            user_id = access_token['user_id']
            
            # Get user
            user = User.objects.get(id=user_id)
            return user
            
        except (InvalidToken, TokenError, User.DoesNotExist, KeyError, ValueError):
            return AnonymousUser()
```

# ==== apps/schedules/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 18:20

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='SchedulePeriod',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('start_date', models.DateField()),
                ('end_date', models.DateField()),
                ('status', models.CharField(choices=[('OPEN', 'Open'), ('LOCKED', 'Locked'), ('FINALIZED', 'Finalized')], default='OPEN', max_length=10)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('created_by', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'schedule_periods',
                'ordering': ['-start_date'],
            },
        ),
    ]
```

# ==== apps/schedules/migrations/__init__.py ====

```python

```

# ==== apps/schedules/models.py ====

```python
# apps/schedules/models.py - NEEDS TO BE CREATED
from django.db import models
from django.conf import settings

class SchedulePeriod(models.Model):
    STATUS_CHOICES = [
        ('OPEN', 'Open'),
        ('LOCKED', 'Locked'),
        ('FINALIZED', 'Finalized'),
    ]
    
    name = models.CharField(max_length=100)
    start_date = models.DateField()
    end_date = models.DateField()
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='OPEN')
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.PROTECT)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'schedule_periods'
        ordering = ['-start_date']
```

# ==== apps/schedules/routing.py ====

```python
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/schedule/(?P<period_id>\d+)/$', consumers.ScheduleConsumer.as_asgi()),
]
```

# ==== apps/schedules/serializers.py ====

```python
from rest_framework import serializers
from .models import SchedulePeriod
from apps.shifts.models import ShiftRequest
from apps.users.serializers import UserSerializer
from datetime import datetime, timedelta


class SchedulePeriodSerializer(serializers.ModelSerializer):
    """Basic serializer for listing schedule periods"""
    created_by_name = serializers.CharField(source='created_by.get_full_name', read_only=True)
    shift_count = serializers.SerializerMethodField()
    
    class Meta:
        model = SchedulePeriod
        fields = [
            'id', 'name', 'start_date', 'end_date', 'status',
            'created_by', 'created_by_name', 'shift_count',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'created_by', 'created_at', 'updated_at']
    
    def get_shift_count(self, obj):
        """Count total shifts in this period"""
        return obj.shiftrequest_set.count()
    
    def validate(self, data):
        """Validate that end_date is after start_date"""
        if data.get('end_date') and data.get('start_date'):
            if data['end_date'] < data['start_date']:
                raise serializers.ValidationError({
                    'end_date': 'End date must be after start date.'
                })
        return data


class SchedulePeriodDetailSerializer(SchedulePeriodSerializer):
    """Detailed serializer including all shifts"""
    shifts = serializers.SerializerMethodField()
    coverage_summary = serializers.SerializerMethodField()
    
    class Meta(SchedulePeriodSerializer.Meta):
        fields = SchedulePeriodSerializer.Meta.fields + ['shifts', 'coverage_summary']
    
    def get_shifts(self, obj):
        """Return all shifts"""
        from apps.shifts.serializers import ShiftRequestSerializer
        shifts = obj.shiftrequest_set.all().order_by('date', 'start_time')
        return ShiftRequestSerializer(shifts, many=True).data
    
    def get_coverage_summary(self, obj):
        """Summary of coverage for this period"""
        total_shifts = obj.shiftrequest_set.filter(status='APPROVED').count()
        pending_requests = obj.shiftrequest_set.filter(status='PENDING').count()
        
        return {
            'total_approved_shifts': total_shifts,
            'pending_requests': pending_requests,
            'status': obj.status
        }


class SchedulePeriodCreateUpdateSerializer(serializers.ModelSerializer):
    """Serializer for creating/updating periods"""
    class Meta:
        model = SchedulePeriod
        fields = ['name', 'start_date', 'end_date', 'status']
    
    def validate(self, data):
        """Validate dates"""
        if data.get('end_date') and data.get('start_date'):
            if data['end_date'] < data['start_date']:
                raise serializers.ValidationError({
                    'end_date': 'End date must be after start date.'
                })
        return data


class CalendarShiftSerializer(serializers.ModelSerializer):
    """Simplified shift serializer for calendar views"""
    pa_name = serializers.CharField(source='requested_by.get_full_name', read_only=True)
    pa_id = serializers.IntegerField(source='requested_by.id', read_only=True)
    
    class Meta:
        model = ShiftRequest
        fields = [
            'id', 'pa_id', 'pa_name', 'date', 
            'start_time', 'end_time', 'duration_hours',
            'notes', 'status'
        ]


class DayScheduleSerializer(serializers.Serializer):
    """Serializer for a single day's schedule"""
    date = serializers.DateField()
    day_name = serializers.CharField()
    shifts = CalendarShiftSerializer(many=True)
    coverage = serializers.DictField()
    total_hours = serializers.DecimalField(max_digits=5, decimal_places=2)


class WeekScheduleSerializer(serializers.Serializer):
    """Serializer for a week's schedule"""
    week_start = serializers.DateField()
    week_end = serializers.DateField()
    week_number = serializers.IntegerField()
    days = DayScheduleSerializer(many=True)


class MonthScheduleSerializer(serializers.Serializer):
    """Serializer for a month's schedule"""
    year = serializers.IntegerField()
    month = serializers.IntegerField()
    month_name = serializers.CharField()
    weeks = WeekScheduleSerializer(many=True)
    total_shifts = serializers.IntegerField()
    coverage_stats = serializers.DictField()
```

# ==== apps/schedules/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/schedules/urls.py ====

```python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import (
    SchedulePeriodViewSet,
    MonthViewAPI,
    WeekViewAPI,
    DayViewAPI
)

app_name = 'schedules'

router = DefaultRouter()
router.register(r'schedule-periods', SchedulePeriodViewSet, basename='schedule-period')

urlpatterns = [
    path('', include(router.urls)),
    
    # Calendar views
    path('calendar/month/<int:year>/<int:month>/', MonthViewAPI.as_view(), name='month-view'),
    path('calendar/week/<int:year>/<int:week>/', WeekViewAPI.as_view(), name='week-view'),
    path('calendar/day/<str:date>/', DayViewAPI.as_view(), name='day-view'),
]
```

# ==== apps/schedules/utils.py ====

```python
from datetime import datetime, timedelta, time
from calendar import monthrange
from apps.shifts.models import ShiftRequest
from apps.coverage.models import CriticalTimeCoverage


def get_coverage_for_date(date):
    """
    Get coverage status for a specific date.
    Returns dict with morning_covered, evening_covered, and coverage_status.
    """
    try:
        coverage = CriticalTimeCoverage.objects.get(date=date)
        return {
            'morning_covered': coverage.morning_covered,
            'evening_covered': coverage.evening_covered,
            'coverage_status': coverage.coverage_status,
        }
    except CriticalTimeCoverage.DoesNotExist:
        # Check shifts for this date to determine coverage
        shifts = ShiftRequest.objects.filter(
            date=date,
            status='APPROVED'
        )
        
        morning_covered = False
        evening_covered = False
        
        for shift in shifts:
            # Morning: 6:00 AM - 9:00 AM (must cover full 3 hours)
            if shift.start_time <= time(6, 0) and shift.end_time >= time(9, 0):
                morning_covered = True
            
            # Evening: 9:00 PM - 10:00 PM (must cover full 1 hour)
            if shift.start_time <= time(21, 0) and shift.end_time >= time(22, 0):
                evening_covered = True
        
        if morning_covered and evening_covered:
            status = 'complete'
        elif morning_covered or evening_covered:
            status = 'partial'
        else:
            status = 'none'
        
        return {
            'morning_covered': morning_covered,
            'evening_covered': evening_covered,
            'coverage_status': status,
        }


def get_shifts_for_date(date):
    """Get all approved shifts for a specific date"""
    return ShiftRequest.objects.filter(
        date=date,
        status='APPROVED'
    ).select_related('requested_by').order_by('start_time')


def get_month_data(year, month):
    """
    Get calendar data for an entire month.
    Returns dict with all days and their shifts/coverage.
    """
    # Get first and last day of month
    _, last_day = monthrange(year, month)
    start_date = datetime(year, month, 1).date()
    end_date = datetime(year, month, last_day).date()
    
    # Get all shifts for the month
    shifts = ShiftRequest.objects.filter(
        date__gte=start_date,
        date__lte=end_date,
        status='APPROVED'
    ).select_related('requested_by').order_by('date', 'start_time')
    
    # Organize shifts by date
    shifts_by_date = {}
    for shift in shifts:
        if shift.date not in shifts_by_date:
            shifts_by_date[shift.date] = []
        shifts_by_date[shift.date].append(shift)
    
    # Build day-by-day data
    days = []
    current_date = start_date
    
    while current_date <= end_date:
        coverage = get_coverage_for_date(current_date)
        day_shifts = shifts_by_date.get(current_date, [])
        
        days.append({
            'date': current_date,
            'morning_covered': coverage['morning_covered'],
            'evening_covered': coverage['evening_covered'],
            'coverage_status': coverage['coverage_status'],
            'shifts': day_shifts,
        })
        
        current_date += timedelta(days=1)
    
    # Coverage summary
    total_days = len(days)
    complete_days = sum(1 for d in days if d['coverage_status'] == 'complete')
    partial_days = sum(1 for d in days if d['coverage_status'] == 'partial')
    no_coverage_days = sum(1 for d in days if d['coverage_status'] == 'none')
    
    return {
        'year': year,
        'month': month,
        'month_name': start_date.strftime('%B %Y'),
        'days': days,
        'total_shifts': len(shifts),
        'coverage_summary': {
            'total_days': total_days,
            'complete_coverage': complete_days,
            'partial_coverage': partial_days,
            'no_coverage': no_coverage_days,
        }
    }


def get_week_data(year, week_number):
    """
    Get calendar data for a specific week.
    Week starts on Monday (ISO week).
    """
    # Get the Monday of the specified week
    jan_4 = datetime(year, 1, 4)
    week_start = jan_4 - timedelta(days=jan_4.weekday()) + timedelta(weeks=week_number - 1)
    week_start = week_start.date()
    week_end = week_start + timedelta(days=6)
    
    # Get all shifts for the week
    shifts = ShiftRequest.objects.filter(
        date__gte=week_start,
        date__lte=week_end,
        status='APPROVED'
    ).select_related('requested_by').order_by('date', 'start_time')
    
    # Organize shifts by date
    shifts_by_date = {}
    for shift in shifts:
        if shift.date not in shifts_by_date:
            shifts_by_date[shift.date] = []
        shifts_by_date[shift.date].append(shift)
    
    # Build day-by-day data for the week
    days = []
    current_date = week_start
    
    for _ in range(7):
        coverage = get_coverage_for_date(current_date)
        day_shifts = shifts_by_date.get(current_date, [])
        
        days.append({
            'date': current_date,
            'morning_covered': coverage['morning_covered'],
            'evening_covered': coverage['evening_covered'],
            'coverage_status': coverage['coverage_status'],
            'shifts': day_shifts,
        })
        
        current_date += timedelta(days=1)
    
    return {
        'year': year,
        'week_number': week_number,
        'week_start': week_start,
        'week_end': week_end,
        'days': days,
        'total_shifts': len(shifts),
    }


def get_day_data(date):
    """
    Get detailed data for a single day including hourly timeline.
    """
    coverage = get_coverage_for_date(date)
    shifts = get_shifts_for_date(date)
    
    # Create hourly timeline (6 AM to 11 PM)
    hourly_timeline = {}
    for hour in range(6, 23):
        hour_start = time(hour, 0)
        hour_end = time(hour + 1, 0) if hour < 23 else time(23, 59)
        
        # Find shifts covering this hour
        covering_shifts = []
        for shift in shifts:
            if shift.start_time <= hour_start and shift.end_time >= hour_end:
                covering_shifts.append({
                    'id': shift.id,
                    'pa_name': shift.requested_by.get_full_name(),
                    'pa_id': shift.requested_by.id,
                })
        
        hourly_timeline[f"{hour:02d}:00"] = covering_shifts
    
    return {
        'date': date,
        'day_name': date.strftime('%A, %B %d, %Y'),
        'morning_covered': coverage['morning_covered'],
        'evening_covered': coverage['evening_covered'],
        'coverage_status': coverage['coverage_status'],
        'shifts': shifts,
        'hourly_timeline': hourly_timeline,
    }
```

# ==== apps/schedules/views.py ====

```python
from rest_framework import viewsets, status, permissions
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.db.models import Sum, Q
from datetime import datetime, timedelta
from calendar import monthrange
from .models import SchedulePeriod
from apps.shifts.models import ShiftRequest
from apps.coverage.models import CriticalTimeCoverage
from .serializers import (
    SchedulePeriodSerializer,
    SchedulePeriodDetailSerializer,
    SchedulePeriodCreateUpdateSerializer,
    CalendarShiftSerializer,
    DayScheduleSerializer,
    WeekScheduleSerializer,
    MonthScheduleSerializer
)


class IsAdminUser(permissions.BasePermission):
    """Custom permission: only admin users"""
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and request.user.role == 'ADMIN'


class SchedulePeriodViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Schedule Periods
    
    List: GET /api/schedule-periods/ (all users)
    Retrieve: GET /api/schedule-periods/{id}/ (all users)
    Create: POST /api/schedule-periods/ (admin only)
    Update: PUT/PATCH /api/schedule-periods/{id}/ (admin only)
    Delete: DELETE /api/schedule-periods/{id}/ (admin only)
    Finalize: POST /api/schedule-periods/{id}/finalize/ (admin only)
    """
    queryset = SchedulePeriod.objects.all().order_by('-start_date')
    
    def get_serializer_class(self):
        """Use different serializers for different actions"""
        if self.action == 'retrieve':
            return SchedulePeriodDetailSerializer
        elif self.action in ['create', 'update', 'partial_update']:
            return SchedulePeriodCreateUpdateSerializer
        return SchedulePeriodSerializer
    
    def get_permissions(self):
        """Admin only for create/update/delete"""
        if self.action in ['create', 'update', 'partial_update', 'destroy', 'finalize']:
            return [IsAdminUser()]
        return [permissions.IsAuthenticated()]
    
    def perform_create(self, serializer):
        """Set created_by to current user"""
        serializer.save(created_by=self.request.user)
    
    @action(detail=True, methods=['post'])
    def finalize(self, request, pk=None):
        """
        Finalize a schedule period (admin only)
        Validates that all critical times are covered before allowing finalization
        """
        period = self.get_object()
        
        if period.status == 'FINALIZED':
            return Response(
                {'error': 'This period is already finalized.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # TODO: Validate critical time coverage (Task 6.4)
        # For now, just finalize
        period.status = 'FINALIZED'
        period.save()
        
        # TODO: Auto-reject all pending requests (Task 6.4)
        # TODO: Send finalized notification email to all PAs (Task 6.4)
        
        return Response({
            'message': 'Schedule period finalized successfully.',
            'period': SchedulePeriodSerializer(period).data
        }, status=status.HTTP_200_OK)


class MonthViewAPI(APIView):
    """
    GET /api/calendar/month/{year}/{month}/
    Returns all approved shifts for a given month in calendar format
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, year, month):
        """Get month view data"""
        try:
            year = int(year)
            month = int(month)
            
            if not (1 <= month <= 12):
                return Response(
                    {'error': 'Month must be between 1 and 12'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Get first and last day of month
            first_day = datetime(year, month, 1).date()
            last_day = datetime(year, month, monthrange(year, month)[1]).date()
            
            # Get all approved shifts for this month
            shifts = ShiftRequest.objects.filter(
                date__gte=first_day,
                date__lte=last_day,
                status='APPROVED'
            ).select_related('requested_by', 'schedule_period').order_by('date', 'start_time')
            
            # Optional: Filter by PA
            pa_id = request.query_params.get('pa_id')
            if pa_id:
                shifts = shifts.filter(requested_by_id=pa_id)
            
            # Group shifts by week
            weeks = []
            current_date = first_day
            
            # Start from Monday of the first week
            while current_date.weekday() != 0:  # 0 = Monday
                current_date -= timedelta(days=1)
            
            week_number = 1
            while current_date <= last_day or current_date.month == month:
                week_start = current_date
                week_end = current_date + timedelta(days=6)
                
                # Get days in this week
                days = []
                for day_offset in range(7):
                    day_date = week_start + timedelta(days=day_offset)
                    
                    # Get shifts for this day
                    day_shifts = [s for s in shifts if s.date == day_date]
                    
                    # Get coverage info
                    coverage = self._get_day_coverage(day_date)
                    
                    # Calculate total hours
                    total_hours = sum(s.duration_hours for s in day_shifts)
                    
                    days.append({
                        'date': day_date,
                        'day_name': day_date.strftime('%A'),
                        'shifts': CalendarShiftSerializer(day_shifts, many=True).data,
                        'coverage': coverage,
                        'total_hours': total_hours,
                        'is_current_month': day_date.month == month
                    })
                
                weeks.append({
                    'week_start': week_start,
                    'week_end': week_end,
                    'week_number': week_number,
                    'days': days
                })
                
                current_date = week_end + timedelta(days=1)
                week_number += 1
                
                # Stop after 6 weeks (max for any month view)
                if week_number > 6:
                    break
            
            # Calculate coverage stats
            coverage_stats = self._get_month_coverage_stats(first_day, last_day)
            
            response_data = {
                'year': year,
                'month': month,
                'month_name': first_day.strftime('%B %Y'),
                'weeks': weeks,
                'total_shifts': shifts.count(),
                'coverage_stats': coverage_stats
            }
            
            return Response(response_data)
            
        except ValueError:
            return Response(
                {'error': 'Invalid year or month'},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    def _get_day_coverage(self, date):
        """Get coverage status for a specific day"""
        try:
            coverage = CriticalTimeCoverage.objects.get(date=date)
            return {
                'morning_covered': coverage.morning_covered,
                'evening_covered': coverage.evening_covered,
                'status': coverage.coverage_status
            }
        except CriticalTimeCoverage.DoesNotExist:
            return {
                'morning_covered': False,
                'evening_covered': False,
                'status': 'none'
            }
    
    def _get_month_coverage_stats(self, start_date, end_date):
        """Calculate coverage statistics for the month"""
        total_days = (end_date - start_date).days + 1
        
        coverage_records = CriticalTimeCoverage.objects.filter(
            date__gte=start_date,
            date__lte=end_date
        )
        
        fully_covered = coverage_records.filter(
            morning_covered=True,
            evening_covered=True
        ).count()
        
        partially_covered = coverage_records.filter(
            Q(morning_covered=True, evening_covered=False) |
            Q(morning_covered=False, evening_covered=True)
        ).count()
        
        not_covered = total_days - fully_covered - partially_covered
        
        return {
            'total_days': total_days,
            'fully_covered': fully_covered,
            'partially_covered': partially_covered,
            'not_covered': not_covered,
            'coverage_percentage': round((fully_covered / total_days * 100), 1) if total_days > 0 else 0
        }


class WeekViewAPI(APIView):
    """
    GET /api/calendar/week/{year}/{week}/
    Returns all approved shifts for a given week (ISO week number)
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, year, week):
        """Get week view data"""
        try:
            year = int(year)
            week = int(week)
            
            if not (1 <= week <= 53):
                return Response(
                    {'error': 'Week must be between 1 and 53'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            # Get Monday of the specified week
            first_day_of_year = datetime(year, 1, 1).date()
            week_start = first_day_of_year + timedelta(weeks=week-1)
            
            # Adjust to Monday
            while week_start.weekday() != 0:
                week_start -= timedelta(days=1)
            
            week_end = week_start + timedelta(days=6)
            
            # Get all approved shifts for this week
            shifts = ShiftRequest.objects.filter(
                date__gte=week_start,
                date__lte=week_end,
                status='APPROVED'
            ).select_related('requested_by', 'schedule_period').order_by('date', 'start_time')
            
            # Optional: Filter by PA
            pa_id = request.query_params.get('pa_id')
            if pa_id:
                shifts = shifts.filter(requested_by_id=pa_id)
            
            # Build days array
            days = []
            for day_offset in range(7):
                day_date = week_start + timedelta(days=day_offset)
                
                # Get shifts for this day
                day_shifts = [s for s in shifts if s.date == day_date]
                
                # Get coverage info
                coverage = self._get_day_coverage(day_date)
                
                # Calculate total hours
                total_hours = sum(s.duration_hours for s in day_shifts)
                
                # Group shifts by hour for timeline view
                hourly_shifts = self._group_shifts_by_hour(day_shifts)
                
                days.append({
                    'date': day_date,
                    'day_name': day_date.strftime('%A'),
                    'shifts': CalendarShiftSerializer(day_shifts, many=True).data,
                    'hourly_shifts': hourly_shifts,
                    'coverage': coverage,
                    'total_hours': total_hours
                })
            
            response_data = {
                'week_start': week_start,
                'week_end': week_end,
                'week_number': week,
                'year': year,
                'days': days,
                'total_shifts': shifts.count()
            }
            
            return Response(response_data)
            
        except ValueError:
            return Response(
                {'error': 'Invalid year or week'},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    def _get_day_coverage(self, date):
        """Get coverage status for a specific day"""
        try:
            coverage = CriticalTimeCoverage.objects.get(date=date)
            return {
                'morning_covered': coverage.morning_covered,
                'evening_covered': coverage.evening_covered,
                'status': coverage.coverage_status
            }
        except CriticalTimeCoverage.DoesNotExist:
            return {
                'morning_covered': False,
                'evening_covered': False,
                'status': 'none'
            }
    
    def _group_shifts_by_hour(self, shifts):
        """Group shifts by hour for timeline display"""
        hourly = {}
        for hour in range(24):
            hourly[f'{hour:02d}:00'] = []
        
        for shift in shifts:
            start_hour = shift.start_time.hour
            hourly[f'{start_hour:02d}:00'].append(
                CalendarShiftSerializer(shift).data
            )
        
        return hourly


class DayViewAPI(APIView):
    """
    GET /api/calendar/day/{date}/
    Returns all approved shifts for a specific day with hourly breakdown
    Date format: YYYY-MM-DD
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, date):
        """Get day view data"""
        try:
            day_date = datetime.strptime(date, '%Y-%m-%d').date()
            
            # Get all approved shifts for this day
            shifts = ShiftRequest.objects.filter(
                date=day_date,
                status='APPROVED'
            ).select_related('requested_by', 'schedule_period').order_by('start_time')
            
            # Optional: Filter by PA
            pa_id = request.query_params.get('pa_id')
            if pa_id:
                shifts = shifts.filter(requested_by_id=pa_id)
            
            # Get coverage info
            try:
                coverage = CriticalTimeCoverage.objects.get(date=day_date)
                coverage_data = {
                    'morning_covered': coverage.morning_covered,
                    'evening_covered': coverage.evening_covered,
                    'morning_shift': CalendarShiftSerializer(coverage.morning_shift).data if coverage.morning_shift else None,
                    'evening_shift': CalendarShiftSerializer(coverage.evening_shift).data if coverage.evening_shift else None,
                    'status': coverage.coverage_status
                }
            except CriticalTimeCoverage.DoesNotExist:
                coverage_data = {
                    'morning_covered': False,
                    'evening_covered': False,
                    'morning_shift': None,
                    'evening_shift': None,
                    'status': 'none'
                }
            
            # Calculate total hours
            total_hours = sum(s.duration_hours for s in shifts)
            
            # Create hourly timeline
            timeline = []
            for hour in range(24):
                hour_shifts = [
                    s for s in shifts 
                    if s.start_time.hour <= hour < s.end_time.hour or
                    (s.start_time.hour > s.end_time.hour and (hour >= s.start_time.hour or hour < s.end_time.hour))
                ]
                
                timeline.append({
                    'hour': hour,
                    'hour_label': f'{hour:02d}:00',
                    'shifts': CalendarShiftSerializer(hour_shifts, many=True).data,
                    'is_critical_time': (6 <= hour < 9) or (21 <= hour < 22)  # 6-9 AM or 9-10 PM
                })
            
            response_data = {
                'date': day_date,
                'day_name': day_date.strftime('%A, %B %d, %Y'),
                'shifts': CalendarShiftSerializer(shifts, many=True).data,
                'coverage': coverage_data,
                'total_hours': total_hours,
                'timeline': timeline
            }
            
            return Response(response_data)
            
        except ValueError:
            return Response(
                {'error': 'Invalid date format. Use YYYY-MM-DD'},
                status=status.HTTP_400_BAD_REQUEST
            )
```

# ==== apps/schedules/websocket_utils.py ====

```python
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from apps.shifts.serializers import ShiftRequestSerializer
import logging

logger = logging.getLogger(__name__)


def broadcast_shift_event(event_type, shift, message=None, changes=None):
    """
    Broadcast shift events to WebSocket clients.
    
    Args:
        event_type: Type of event (requested, approved, rejected, updated, deleted)
        shift: ShiftRequest instance (or None for deleted)
        message: Optional custom message
        changes: Optional dict of changes (for updated events)
    """
    channel_layer = get_channel_layer()
    
    if shift and hasattr(shift, 'schedule_period'):
        period_id = shift.schedule_period.id
        room_group_name = f'schedule_{period_id}'
        
        # Prepare shift data
        if event_type != 'deleted':
            shift_data = ShiftRequestSerializer(shift).data
        else:
            shift_data = None
        
        # Prepare event data
        event_data = {
            'type': f'shift_{event_type}',  # Converts to shift_requested, shift_approved, etc.
            'message': message or f'Shift {event_type}'
        }
        
        if shift_data:
            event_data['shift'] = shift_data
        
        if event_type == 'deleted':
            event_data['shift_id'] = shift.id if shift else None
        
        if changes:
            event_data['changes'] = changes
        
        # Broadcast to group
        try:
            async_to_sync(channel_layer.group_send)(
                room_group_name,
                event_data
            )
            logger.info(f'WebSocket broadcast: {event_type} for shift {shift.id if shift else "N/A"} in period {period_id}')
        except Exception as e:
            logger.error(f'Failed to broadcast WebSocket event: {e}')


def broadcast_coverage_alert(date, coverage, period_id, message=None):
    """
    Broadcast coverage alert to WebSocket clients.
    
    Args:
        date: Date of coverage change
        coverage: Coverage data dict
        period_id: Schedule period ID
        message: Optional custom message
    """
    channel_layer = get_channel_layer()
    room_group_name = f'schedule_{period_id}'
    
    event_data = {
        'type': 'coverage_alert',
        'date': str(date),
        'coverage': coverage,
        'message': message or 'Coverage status updated'
    }
    
    try:
        async_to_sync(channel_layer.group_send)(
            room_group_name,
            event_data
        )
        logger.info(f'WebSocket broadcast: coverage alert for {date} in period {period_id}')
    except Exception as e:
        logger.error(f'Failed to broadcast coverage alert: {e}')


def broadcast_period_finalized(period, message=None):
    """
    Broadcast period finalization to WebSocket clients.
    
    Args:
        period: SchedulePeriod instance
        message: Optional custom message
    """
    channel_layer = get_channel_layer()
    room_group_name = f'schedule_{period.id}'
    
    from apps.schedules.serializers import SchedulePeriodSerializer
    
    event_data = {
        'type': 'period_finalized',
        'period': SchedulePeriodSerializer(period).data,
        'message': message or f'{period.name} has been finalized'
    }
    
    try:
        async_to_sync(channel_layer.group_send)(
            room_group_name,
            event_data
        )
        logger.info(f'WebSocket broadcast: period {period.id} finalized')
    except Exception as e:
        logger.error(f'Failed to broadcast period finalized: {e}')
```

# ==== apps/shifts/__init__.py ====

```python

```

# ==== apps/shifts/admin.py ====

```python
from django.contrib import admin
from .models import ShiftRequest


@admin.register(ShiftRequest)
class ShiftRequestAdmin(admin.ModelAdmin):
    list_display = [
        'id', 'date', 'start_time', 'end_time', 'requested_by',
        'status', 'duration_hours', 'schedule_period', 'created_at'
    ]
    list_filter = ['status', 'date', 'schedule_period']
    search_fields = ['requested_by__email', 'requested_by__first_name', 'requested_by__last_name']
    readonly_fields = ['duration_hours', 'created_at', 'updated_at', 'approved_at']
    
    fieldsets = (
        ('Shift Details', {
            'fields': ('schedule_period', 'requested_by', 'date', 'start_time', 'end_time', 'duration_hours')
        }),
        ('Status', {
            'fields': ('status', 'approved_by', 'approved_at')
        }),
        ('Notes', {
            'fields': ('notes', 'admin_notes', 'rejected_reason')
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related(
            'schedule_period', 'requested_by', 'approved_by'
        )
```

# ==== apps/shifts/apps.py ====

```python
from django.apps import AppConfig


class ShiftsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.shifts'
```

# ==== apps/shifts/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 18:20

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('schedules', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ShiftRequest',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField()),
                ('start_time', models.TimeField()),
                ('end_time', models.TimeField()),
                ('duration_hours', models.DecimalField(decimal_places=2, max_digits=4)),
                ('status', models.CharField(choices=[('PENDING', 'Pending'), ('APPROVED', 'Approved'), ('REJECTED', 'Rejected'), ('CANCELLED', 'Cancelled')], default='PENDING', max_length=10)),
                ('notes', models.TextField(blank=True)),
                ('admin_notes', models.TextField(blank=True)),
                ('rejected_reason', models.TextField(blank=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('approved_at', models.DateTimeField(blank=True, null=True)),
                ('approved_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='approved_shifts', to=settings.AUTH_USER_MODEL)),
                ('requested_by', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                ('schedule_period', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='schedules.scheduleperiod')),
            ],
            options={
                'db_table': 'shift_requests',
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/shifts/migrations/__init__.py ====

```python

```

# ==== apps/shifts/models.py ====

```python
# apps/shifts/models.py - NEEDS TO BE CREATED
from django.db import models
from django.conf import settings
from decimal import Decimal

class ShiftRequest(models.Model):
    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('APPROVED', 'Approved'),
        ('REJECTED', 'Rejected'),
        ('CANCELLED', 'Cancelled'),
    ]
    
    schedule_period = models.ForeignKey('schedules.SchedulePeriod', on_delete=models.CASCADE)
    requested_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    date = models.DateField()
    start_time = models.TimeField()
    end_time = models.TimeField()
    duration_hours = models.DecimalField(max_digits=4, decimal_places=2)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='PENDING')
    notes = models.TextField(blank=True)
    admin_notes = models.TextField(blank=True)
    rejected_reason = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    approved_at = models.DateTimeField(null=True, blank=True)
    approved_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='approved_shifts'
    )
    
    class Meta:
        db_table = 'shift_requests'
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        # Auto-calculate duration
        if self.start_time and self.end_time:
            from datetime import datetime, timedelta
            start = datetime.combine(datetime.today(), self.start_time)
            end = datetime.combine(datetime.today(), self.end_time)
            if end < start:
                end += timedelta(days=1)
            duration = (end - start).total_seconds() / 3600
            self.duration_hours = Decimal(str(duration))
        super().save(*args, **kwargs)
```

# ==== apps/shifts/serializers.py ====

```python
from rest_framework import serializers
from django.utils import timezone
from datetime import datetime, timedelta
from .models import ShiftRequest
from apps.schedules.models import SchedulePeriod
from apps.users.serializers import UserSerializer


class ShiftRequestSerializer(serializers.ModelSerializer):
    """Main serializer for shift requests"""
    requested_by_name = serializers.CharField(source='requested_by.get_full_name', read_only=True)
    approved_by_name = serializers.CharField(source='approved_by.get_full_name', read_only=True)
    schedule_period_name = serializers.CharField(source='schedule_period.name', read_only=True)
    
    class Meta:
        model = ShiftRequest
        fields = [
            'id', 'schedule_period', 'schedule_period_name',
            'requested_by', 'requested_by_name',
            'date', 'start_time', 'end_time', 'duration_hours',
            'status', 'notes', 'admin_notes', 'rejected_reason',
            'created_at', 'updated_at', 'approved_at', 
            'approved_by', 'approved_by_name'
        ]
        read_only_fields = [
            'id', 'duration_hours', 'status', 'approved_at', 
            'approved_by', 'created_at', 'updated_at', 'requested_by'
        ]


class ShiftRequestCreateSerializer(serializers.ModelSerializer):
    """Simplified serializer for creating shift requests"""
    
    class Meta:
        model = ShiftRequest
        fields = ['schedule_period', 'date', 'start_time', 'end_time', 'notes']
    
    def validate_schedule_period(self, value):
        """Ensure period is OPEN"""
        if value.status != 'OPEN':
            raise serializers.ValidationError(
                f'Cannot submit requests for {value.status} periods. Period must be OPEN.'
            )
        return value
    
    def validate(self, data):
        """Validate shift request rules"""
        schedule_period = data.get('schedule_period')
        date = data.get('date')
        start_time = data.get('start_time')
        end_time = data.get('end_time')
        
        # Get requested_by from context (set by view)
        request = self.context.get('request')
        if not request or not request.user:
            raise serializers.ValidationError('User context required')
        
        requested_by = request.user
        
        # Validate start_time < end_time
        if start_time and end_time:
            if start_time >= end_time:
                raise serializers.ValidationError({
                    'end_time': 'End time must be after start time.'
                })
        
        # Validate date within period
        if schedule_period and date:
            if not (schedule_period.start_date <= date <= schedule_period.end_date):
                raise serializers.ValidationError({
                    'date': f'Date must be between {schedule_period.start_date} and {schedule_period.end_date}'
                })
        
        # Check for overlapping shifts (same PA, same time)
        if date and start_time and end_time:
            overlapping = ShiftRequest.objects.filter(
                requested_by=requested_by,
                date=date,
                status__in=['PENDING', 'APPROVED']
            )
            
            for shift in overlapping:
                if not (end_time <= shift.start_time or start_time >= shift.end_time):
                    raise serializers.ValidationError({
                        'time': f'You already have a shift from {shift.start_time} to {shift.end_time} on this date.'
                    })
        
        # Check for duplicate pending requests
        if date and start_time and end_time:
            duplicate = ShiftRequest.objects.filter(
                requested_by=requested_by,
                date=date,
                start_time=start_time,
                end_time=end_time,
                status='PENDING'
            ).exists()
            
            if duplicate:
                raise serializers.ValidationError(
                    'You already have a pending request for this exact shift.'
                )
        
        return data


class ShiftApprovalSerializer(serializers.Serializer):
    """Serializer for approving shifts"""
    admin_notes = serializers.CharField(required=False, allow_blank=True)
    override_overtime = serializers.BooleanField(default=False, required=False)


class ShiftRejectionSerializer(serializers.Serializer):
    """Serializer for rejecting shifts"""
    rejected_reason = serializers.CharField(required=True)
```

# ==== apps/shifts/tasks.py ====

```python
from celery import shared_task
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.conf import settings
from django.utils.html import strip_tags
from .models import ShiftRequest
import logging

logger = logging.getLogger(__name__)


@shared_task(bind=True, max_retries=3)
def send_shift_approved_email(self, shift_id):
    """
    Send email notification when a shift is approved.
    Retries up to 3 times on failure.
    """
    try:
        shift = ShiftRequest.objects.select_related(
            'requested_by', 'approved_by', 'schedule_period'
        ).get(id=shift_id)
        
        pa = shift.requested_by
        
        # Context for email templates
        context = {
            'pa_name': pa.get_full_name(),
            'admin_name': shift.approved_by.get_full_name() if shift.approved_by else 'Admin',
            'shift_date': shift.date.strftime('%A, %B %d, %Y'),
            'start_time': shift.start_time.strftime('%I:%M %p'),
            'end_time': shift.end_time.strftime('%I:%M %p'),
            'duration': shift.duration_hours,
            'period_name': shift.schedule_period.name,
            'admin_notes': shift.admin_notes,
            'frontend_url': settings.FRONTEND_URL,
        }
        
        # Render HTML and text versions
        html_message = render_to_string('emails/shift_approved.html', context)
        text_message = render_to_string('emails/shift_approved.txt', context)
        
        # Send email
        send_mail(
            subject=f'✅ Shift Approved: {shift.date.strftime("%b %d, %Y")}',
            message=text_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[pa.email],
            html_message=html_message,
            fail_silently=False,
        )
        
        logger.info(f'Shift approved email sent to {pa.email} for shift {shift_id}')
        return f'Email sent to {pa.email}'
        
    except ShiftRequest.DoesNotExist:
        logger.error(f'Shift {shift_id} not found')
        return f'Shift {shift_id} not found'
    
    except Exception as e:
        logger.error(f'Failed to send shift approved email: {e}')
        # Retry with exponential backoff
        raise self.retry(exc=e, countdown=60 * (2 ** self.request.retries))


@shared_task(bind=True, max_retries=3)
def send_shift_rejected_email(self, shift_id):
    """
    Send email notification when a shift is rejected.
    """
    try:
        shift = ShiftRequest.objects.select_related(
            'requested_by', 'schedule_period'
        ).get(id=shift_id)
        
        pa = shift.requested_by
        
        # Context for email templates
        context = {
            'pa_name': pa.get_full_name(),
            'shift_date': shift.date.strftime('%A, %B %d, %Y'),
            'start_time': shift.start_time.strftime('%I:%M %p'),
            'end_time': shift.end_time.strftime('%I:%M %p'),
            'duration': shift.duration_hours,
            'period_name': shift.schedule_period.name,
            'rejected_reason': shift.rejected_reason,
            'frontend_url': settings.FRONTEND_URL,
        }
        
        # Render HTML and text versions
        html_message = render_to_string('emails/shift_rejected.html', context)
        text_message = render_to_string('emails/shift_rejected.txt', context)
        
        # Send email
        send_mail(
            subject=f'❌ Shift Request Not Approved: {shift.date.strftime("%b %d, %Y")}',
            message=text_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[pa.email],
            html_message=html_message,
            fail_silently=False,
        )
        
        logger.info(f'Shift rejected email sent to {pa.email} for shift {shift_id}')
        return f'Email sent to {pa.email}'
        
    except ShiftRequest.DoesNotExist:
        logger.error(f'Shift {shift_id} not found')
        return f'Shift {shift_id} not found'
    
    except Exception as e:
        logger.error(f'Failed to send shift rejected email: {e}')
        raise self.retry(exc=e, countdown=60 * (2 ** self.request.retries))


@shared_task(bind=True, max_retries=3)
def send_admin_notification_new_request(self, shift_id):
    """
    Send email notification to admin when a new shift is requested.
    """
    try:
        shift = ShiftRequest.objects.select_related(
            'requested_by', 'schedule_period'
        ).get(id=shift_id)
        
        pa = shift.requested_by
        
        # Get all admin users
        from apps.users.models import User
        admin_emails = list(User.objects.filter(role='ADMIN', is_active=True).values_list('email', flat=True))
        
        if not admin_emails:
            logger.warning('No admin users found to send notification')
            return 'No admin users found'
        
        # Context for email templates
        context = {
            'pa_name': pa.get_full_name(),
            'pa_email': pa.email,
            'shift_date': shift.date.strftime('%A, %B %d, %Y'),
            'start_time': shift.start_time.strftime('%I:%M %p'),
            'end_time': shift.end_time.strftime('%I:%M %p'),
            'duration': shift.duration_hours,
            'period_name': shift.schedule_period.name,
            'pa_notes': shift.notes,
            'submitted_at': shift.created_at.strftime('%B %d, %Y at %I:%M %p'),
            'frontend_url': settings.FRONTEND_URL,
        }
        
        # Render HTML and text versions
        html_message = render_to_string('emails/new_request_admin.html', context)
        text_message = render_to_string('emails/new_request_admin.txt', context)
        
        # Send email to all admins
        send_mail(
            subject=f'🔔 New Shift Request from {pa.get_full_name()}',
            message=text_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=admin_emails,
            html_message=html_message,
            fail_silently=False,
        )
        
        logger.info(f'New request notification sent to admins for shift {shift_id}')
        return f'Email sent to {len(admin_emails)} admin(s)'
        
    except ShiftRequest.DoesNotExist:
        logger.error(f'Shift {shift_id} not found')
        return f'Shift {shift_id} not found'
    
    except Exception as e:
        logger.error(f'Failed to send admin notification: {e}')
        raise self.retry(exc=e, countdown=60 * (2 ** self.request.retries))
```

# ==== apps/shifts/templates/emails/new_request_admin.txt ====

```
```
🔔 NEW SHIFT REQUEST

Hi Admin,

{{ pa_name }} has submitted a new shift request that requires your review.

SHIFT REQUEST DETAILS
---------------------
PA: {{ pa_name }} ({{ pa_email }})
Date: {{ shift_date }}
Time: {{ start_time }} - {{ end_time }}
Duration: {{ duration }} hours
Schedule Period: {{ period_name }}
{% if pa_notes %}
PA Notes: {{ pa_notes }}
{% endif %}
Submitted: {{ submitted_at }}

Please review and approve or reject this request at your earliest convenience:
{{ frontend_url }}/admin/approve

Best regards,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/shifts/templates/emails/shift_approved.txt ====

```
✅ SHIFT REQUEST APPROVED

Hi {{ pa_name }},

Great news! Your shift request has been approved by {{ admin_name }}.

SHIFT DETAILS
-------------
Date: {{ shift_date }}
Time: {{ start_time }} - {{ end_time }}
Duration: {{ duration }} hours
Schedule Period: {{ period_name }}
{% if admin_notes %}
Admin Notes: {{ admin_notes }}
{% endif %}

This shift is now part of your schedule. You can view your complete schedule at:
{{ frontend_url }}/schedule

If you have any questions, please contact your administrator.

Thank you,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/shifts/templates/emails/shift_rejected.txt ====

```
 SHIFT REQUEST NOT APPROVED

Hi {{ pa_name }},

Your shift request was not approved. Please see the details below.

SHIFT DETAILS
-------------
Date: {{ shift_date }}
Time: {{ start_time }} - {{ end_time }}
Duration: {{ duration }} hours
Schedule Period: {{ period_name }}

REASON FOR REJECTION
--------------------
{{ rejected_reason }}

If you have questions about this decision or would like to request a different shift, please contact your administrator or submit a new request at:
{{ frontend_url }}/requests/new

Thank you for your understanding.

Best regards,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/shifts/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/shifts/urls.py ====

```python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ShiftRequestViewSet

app_name = 'shifts'

router = DefaultRouter()
router.register(r'shifts', ShiftRequestViewSet, basename='shift')

urlpatterns = [
    path('', include(router.urls)),
]
```

# ==== apps/shifts/views.py ====

```python
from rest_framework import viewsets, status, permissions
from rest_framework.decorators import action
from rest_framework.response import Response
from django.utils import timezone
from django.db.models import Q
from .models import ShiftRequest
from .serializers import (
    ShiftRequestSerializer,
    ShiftRequestCreateSerializer,
    ShiftApprovalSerializer,
    ShiftRejectionSerializer
)
from .tasks import (
    send_shift_approved_email,
    send_shift_rejected_email,
    send_admin_notification_new_request
)
from apps.schedules.websocket_utils import broadcast_shift_event


class IsAdminUser(permissions.BasePermission):
    """Only admin users"""
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and request.user.role == 'ADMIN'


class IsPAUser(permissions.BasePermission):
    """Only PA users"""
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and request.user.role == 'PA'


class IsOwnerOrAdmin(permissions.BasePermission):
    """Owner of the shift or admin"""
    def has_object_permission(self, request, view, obj):
        return (
            request.user.role == 'ADMIN' or 
            obj.requested_by == request.user
        )


class ShiftRequestViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Shift Requests
    
    List: GET /api/shifts/ (filtered by role)
    Create: POST /api/shifts/ (PA creates request, Admin creates direct)
    Retrieve: GET /api/shifts/{id}/
    Update: PATCH /api/shifts/{id}/ (own pending requests only)
    Delete: DELETE /api/shifts/{id}/ (cancel own pending requests)
    Approve: POST /api/shifts/{id}/approve/ (admin only)
    Reject: POST /api/shifts/{id}/reject/ (admin only)
    """
    queryset = ShiftRequest.objects.all().select_related(
        'schedule_period', 'requested_by', 'approved_by'
    ).order_by('-created_at')
    serializer_class = ShiftRequestSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        """Filter queryset based on user role"""
        user = self.request.user
        queryset = super().get_queryset()
        
        if user.role == 'PA':
            queryset = queryset.filter(requested_by=user)
        
        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)
        
        period_id = self.request.query_params.get('period')
        if period_id:
            queryset = queryset.filter(schedule_period_id=period_id)
        
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        if start_date:
            queryset = queryset.filter(date__gte=start_date)
        if end_date:
            queryset = queryset.filter(date__lte=end_date)
        
        return queryset
    
    def get_serializer_class(self):
        """Use create serializer for POST"""
        if self.action == 'create':
            return ShiftRequestCreateSerializer
        return ShiftRequestSerializer
    
    def get_permissions(self):
        """Set permissions based on action"""
        if self.action in ['approve', 'reject']:
            return [IsAdminUser()]
        elif self.action in ['update', 'partial_update', 'destroy']:
            return [permissions.IsAuthenticated(), IsOwnerOrAdmin()]
        return [permissions.IsAuthenticated()]
    
    def perform_create(self, serializer):
        """Set requested_by to current user"""
        user = self.request.user
        
        admin_direct = self.request.data.get('admin_direct', False)
        if user.role == 'ADMIN' and admin_direct:
            shift = serializer.save(
                requested_by=user,
                status='APPROVED',
                approved_by=user,
                approved_at=timezone.now()
            )
            broadcast_shift_event('approved', shift, message='Admin created shift directly')
            return
        
        shift = serializer.save(requested_by=user, status='PENDING')
        
        send_admin_notification_new_request.delay(shift.id)
        
        broadcast_shift_event('requested', shift, message=f'{user.get_full_name()} submitted a new shift request')
    
    def update(self, request, *args, **kwargs):
        """Only allow updating pending requests"""
        instance = self.get_object()
        
        if request.user.role == 'PA':
            if instance.requested_by != request.user:
                return Response(
                    {'error': 'You can only edit your own requests.'},
                    status=status.HTTP_403_FORBIDDEN
                )
            if instance.status != 'PENDING':
                return Response(
                    {'error': 'You can only edit pending requests.'},
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        return super().update(request, *args, **kwargs)
    
    def destroy(self, request, *args, **kwargs):
        """Allow canceling pending requests or admin deletion"""
        instance = self.get_object()
        
        if request.user.role == 'PA':
            if instance.requested_by != request.user:
                return Response(
                    {'error': 'You can only cancel your own requests.'},
                    status=status.HTTP_403_FORBIDDEN
                )
            if instance.status != 'PENDING':
                return Response(
                    {'error': 'You can only cancel pending requests.'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            instance.status = 'CANCELLED'
            instance.save()
            
            broadcast_shift_event('deleted', instance, message=f'Shift cancelled by {request.user.get_full_name()}')
            
            return Response({'message': 'Request cancelled successfully.'})
        
        shift_id = instance.id
        period_id = instance.schedule_period.id
        result = super().destroy(request, *args, **kwargs)
        
        class DeletedShift:
            id = shift_id
            schedule_period = type('obj', (object,), {'id': period_id})
        
        broadcast_shift_event('deleted', DeletedShift(), message=f'Shift deleted by admin')
        
        return result
    
    @action(detail=False, methods=['get'])
    def pending(self, request):
        """Get all pending requests (admin only)"""
        if request.user.role != 'ADMIN':
            return Response(
                {'error': 'Admin access required.'},
                status=status.HTTP_403_FORBIDDEN
            )
        
        pending_requests = self.get_queryset().filter(status='PENDING')
        serializer = self.get_serializer(pending_requests, many=True)
        return Response(serializer.data)
    
    @action(detail=False, methods=['get'])
    def my_schedule(self, request):
        """Get my approved shifts (PA only)"""
        if request.user.role != 'PA':
            return Response(
                {'error': 'PA access only.'},
                status=status.HTTP_403_FORBIDDEN
            )
        
        approved_shifts = self.get_queryset().filter(
            status='APPROVED',
            requested_by=request.user
        ).order_by('date', 'start_time')
        
        serializer = self.get_serializer(approved_shifts, many=True)
        return Response(serializer.data)
    
    @action(detail=True, methods=['post'])
    def approve(self, request, pk=None):
        """
        Approve a shift request (admin only)
        Validates no conflicts and updates coverage
        """
        shift = self.get_object()
        
        if shift.status != 'PENDING':
            return Response(
                {'error': f'Cannot approve {shift.status} request.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        serializer = ShiftApprovalSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        conflicting_shifts = ShiftRequest.objects.filter(
            date=shift.date,
            status='APPROVED'
        ).exclude(pk=shift.pk)
        
        for other_shift in conflicting_shifts:
            if not (shift.end_time <= other_shift.start_time or 
                    shift.start_time >= other_shift.end_time):
                return Response({
                    'error': f'Conflict detected: {other_shift.requested_by.get_full_name()} '
                             f'already has a shift from {other_shift.start_time} to {other_shift.end_time}'
                }, status=status.HTTP_400_BAD_REQUEST)
        
        shift.status = 'APPROVED'
        shift.approved_by = request.user
        shift.approved_at = timezone.now()
        if serializer.validated_data.get('admin_notes'):
            shift.admin_notes = serializer.validated_data['admin_notes']
        shift.save()
        
        send_shift_approved_email.delay(shift.id)
        
        broadcast_shift_event('approved', shift, message=f'Shift approved by {request.user.get_full_name()}')
        
        return Response({
            'message': 'Shift approved successfully.',
            'shift': ShiftRequestSerializer(shift).data
        })
    
    @action(detail=True, methods=['post'])
    def reject(self, request, pk=None):
        """Reject a shift request (admin only)"""
        shift = self.get_object()
        
        if shift.status != 'PENDING':
            return Response(
                {'error': f'Cannot reject {shift.status} request.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        serializer = ShiftRejectionSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        shift.status = 'REJECTED'
        shift.rejected_reason = serializer.validated_data['rejected_reason']
        shift.save()
        
        send_shift_rejected_email.delay(shift.id)
        
        broadcast_shift_event('rejected', shift, message=f'Shift rejected by {request.user.get_full_name()}')
        
        return Response({
            'message': 'Shift rejected.',
            'shift': ShiftRequestSerializer(shift).data
        })
```

# ==== apps/users/__init__.py ====

```python

```

# ==== apps/users/admin.py ====

```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User, EmailVerificationToken, PasswordResetToken


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    list_display = ['email', 'username', 'first_name', 'last_name', 'role', 'is_email_verified', 'is_active']
    list_filter = ['role', 'is_email_verified', 'is_active', 'date_joined']
    search_fields = ['email', 'username', 'first_name', 'last_name']
    ordering = ['-date_joined']
    
    fieldsets = (
        (None, {'fields': ('email', 'username', 'password')}),
        ('Personal Info', {'fields': ('first_name', 'last_name', 'phone_number')}),
        ('Permissions', {'fields': ('role', 'is_active', 'is_staff', 'is_superuser', 'is_email_verified')}),
        ('Important dates', {'fields': ('last_login', 'date_joined')}),
    )
    
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'username', 'password1', 'password2', 'first_name', 'last_name', 'phone_number', 'role'),
        }),
    )


@admin.register(EmailVerificationToken)
class EmailVerificationTokenAdmin(admin.ModelAdmin):
    list_display = ['user', 'token', 'created_at', 'expires_at', 'used']
    list_filter = ['used', 'created_at']
    search_fields = ['user__email', 'token']
    readonly_fields = ['token', 'created_at']


@admin.register(PasswordResetToken)
class PasswordResetTokenAdmin(admin.ModelAdmin):
    list_display = ['user', 'token', 'created_at', 'expires_at', 'used']
    list_filter = ['used', 'created_at']
    search_fields = ['user__email', 'token']
    readonly_fields = ['token', 'created_at']
```

# ==== apps/users/apps.py ====

```python
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.users'
```

# ==== apps/users/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 17:33

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('email', models.EmailField(db_index=True, max_length=254, unique=True)),
                ('phone_number', models.CharField(max_length=20)),
                ('role', models.CharField(choices=[('ADMIN', 'Admin'), ('PA', 'Personal Assistant')], default='PA', max_length=10)),
                ('is_email_verified', models.BooleanField(default=False)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'User',
                'verbose_name_plural': 'Users',
                'db_table': 'users',
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]
```

# ==== apps/users/migrations/0002_emailverificationtoken_passwordresettoken.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 18:04

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('users', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='EmailVerificationToken',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('token', models.UUIDField(default=uuid.uuid4, editable=False, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField()),
                ('used', models.BooleanField(default=False)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='verification_tokens', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'email_verification_tokens',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='PasswordResetToken',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('token', models.UUIDField(default=uuid.uuid4, editable=False, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField()),
                ('used', models.BooleanField(default=False)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='password_reset_tokens', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'password_reset_tokens',
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/users/migrations/__init__.py ====

```python

```

# ==== apps/users/models.py ====

```python
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils import timezone
import uuid
from datetime import timedelta


class User(AbstractUser):
    """
    Custom User model extending Django's AbstractUser.
    Email is the primary identifier instead of username.
    """
    email = models.EmailField(unique=True, db_index=True)
    phone_number = models.CharField(max_length=20)
    
    ROLE_CHOICES = [
        ('ADMIN', 'Admin'),
        ('PA', 'Personal Assistant'),
    ]
    role = models.CharField(max_length=10, choices=ROLE_CHOICES, default='PA')
    
    is_email_verified = models.BooleanField(default=False)
    
    # Make email the login field instead of username
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username', 'first_name', 'last_name']
    
    class Meta:
        db_table = 'users'
        verbose_name = 'User'
        verbose_name_plural = 'Users'
    
    def __str__(self):
        return f"{self.email} ({self.get_role_display()})"
    
    def save(self, *args, **kwargs):
        # Normalize email to lowercase
        if self.email:
            self.email = self.email.lower()
        super().save(*args, **kwargs)


class EmailVerificationToken(models.Model):
    """Token for email verification"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='verification_tokens')
    token = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    used = models.BooleanField(default=False)
    
    class Meta:
        db_table = 'email_verification_tokens'
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        if not self.expires_at:
            self.expires_at = timezone.now() + timedelta(days=7)
        super().save(*args, **kwargs)
    
    def is_valid(self):
        """Check if token is still valid"""
        return not self.used and timezone.now() < self.expires_at
    
    def __str__(self):
        return f"Verification token for {self.user.email}"


class PasswordResetToken(models.Model):
    """Token for password reset"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='password_reset_tokens')
    token = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    used = models.BooleanField(default=False)
    
    class Meta:
        db_table = 'password_reset_tokens'
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        if not self.expires_at:
            self.expires_at = timezone.now() + timedelta(hours=24)
        super().save(*args, **kwargs)
    
    def is_valid(self):
        """Check if token is still valid"""
        return not self.used and timezone.now() < self.expires_at
    
    def __str__(self):
        return f"Password reset token for {self.user.email}"
```

# ==== apps/users/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from .models import User


class UserSerializer(serializers.ModelSerializer):
    """Serializer for User responses"""
    class Meta:
        model = User
        fields = ['id', 'email', 'username', 'first_name', 'last_name', 
                  'phone_number', 'role', 'is_email_verified', 'date_joined']
        read_only_fields = ['id', 'date_joined', 'is_email_verified']


class RegisterSerializer(serializers.ModelSerializer):
    """Serializer for user registration"""
    password = serializers.CharField(
        write_only=True, 
        required=True, 
        validators=[validate_password],
        style={'input_type': 'password'}
    )
    password_confirm = serializers.CharField(
        write_only=True, 
        required=True,
        style={'input_type': 'password'}
    )

    class Meta:
        model = User
        fields = ['email', 'username', 'password', 'password_confirm', 
                  'first_name', 'last_name', 'phone_number']

    def validate_email(self, value):
        """Ensure email is lowercase and unique"""
        value = value.lower()
        if User.objects.filter(email=value).exists():
            raise serializers.ValidationError("A user with this email already exists.")
        return value

    def validate(self, attrs):
        """Check that passwords match"""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({
                "password": "Password fields didn't match."
            })
        return attrs

    def create(self, validated_data):
        """Create new user with hashed password"""
        validated_data.pop('password_confirm')
        user = User.objects.create_user(
            email=validated_data['email'],
            username=validated_data['username'],
            password=validated_data['password'],
            first_name=validated_data.get('first_name', ''),
            last_name=validated_data.get('last_name', ''),
            phone_number=validated_data['phone_number'],
            role='PA'  # Default role is PA
        )
        return user


class LoginSerializer(serializers.Serializer):
    """Serializer for user login"""
    email = serializers.EmailField()
    password = serializers.CharField(
        write_only=True,
        style={'input_type': 'password'}
    )

    def validate_email(self, value):
        """Normalize email to lowercase"""
        return value.lower()

    def validate(self, attrs):
        """Authenticate user"""
        email = attrs.get('email')
        password = attrs.get('password')

        if email and password:
            # Try to authenticate
            user = authenticate(
                request=self.context.get('request'),
                username=email,  # We use email as username
                password=password
            )

            if not user:
                raise serializers.ValidationError(
                    'Unable to log in with provided credentials.',
                    code='authorization'
                )
            
            if not user.is_active:
                raise serializers.ValidationError(
                    'User account is disabled.',
                    code='authorization'
                )

            attrs['user'] = user
            return attrs
        else:
            raise serializers.ValidationError(
                'Must include "email" and "password".',
                code='authorization'
            )


class PasswordResetRequestSerializer(serializers.Serializer):
    """Serializer for requesting password reset"""
    email = serializers.EmailField()

    def validate_email(self, value):
        """Normalize email to lowercase"""
        return value.lower()


class PasswordResetConfirmSerializer(serializers.Serializer):
    """Serializer for confirming password reset"""
    token = serializers.UUIDField()
    password = serializers.CharField(
        write_only=True,
        required=True,
        validators=[validate_password],
        style={'input_type': 'password'}
    )
    password_confirm = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )

    def validate(self, attrs):
        """Check that passwords match"""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({
                "password": "Password fields didn't match."
            })
        return attrs


class EmailVerificationSerializer(serializers.Serializer):
    """Serializer for email verification"""
    token = serializers.UUIDField()


class UserProfileUpdateSerializer(serializers.ModelSerializer):
    """Serializer for updating user profile"""
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'phone_number']

    def validate_phone_number(self, value):
        """Ensure phone number is provided"""
        if not value:
            raise serializers.ValidationError("Phone number is required.")
        return value
```

# ==== apps/users/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/users/urls.py ====

```python
from django.urls import path
from .views import (
    RegisterView,
    VerifyEmailView,
    LoginView,
    RefreshTokenView,
    LogoutView,
    PasswordResetRequestView,
    PasswordResetConfirmView,
    UserProfileView,
)

app_name = 'users'

urlpatterns = [
    # Authentication
    path('register/', RegisterView.as_view(), name='register'),
    path('verify-email/', VerifyEmailView.as_view(), name='verify-email'),
    path('login/', LoginView.as_view(), name='login'),
    path('refresh/', RefreshTokenView.as_view(), name='refresh'),
    path('logout/', LogoutView.as_view(), name='logout'),
    
    # Password Reset
    path('password-reset/', PasswordResetRequestView.as_view(), name='password-reset'),
    path('password-reset-confirm/', PasswordResetConfirmView.as_view(), name='password-reset-confirm'),
    
    # Profile
    path('me/', UserProfileView.as_view(), name='user-profile'),
]
```

# ==== apps/users/views.py ====

```python
from rest_framework import status, generics, permissions
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import get_user_model
from django.shortcuts import get_object_or_404

from .serializers import (
    UserSerializer, 
    RegisterSerializer, 
    LoginSerializer,
    PasswordResetRequestSerializer,
    PasswordResetConfirmSerializer,
    EmailVerificationSerializer,
    UserProfileUpdateSerializer
)
from .models import EmailVerificationToken, PasswordResetToken

User = get_user_model()


class RegisterView(generics.CreateAPIView):
    """
    POST: Register a new PA user
    Creates user and sends verification email
    """
    queryset = User.objects.all()
    serializer_class = RegisterSerializer
    permission_classes = [permissions.AllowAny]

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        
        # Create verification token
        token = EmailVerificationToken.objects.create(user=user)
        
        # TODO: Send verification email (Task 1.3)
        # send_verification_email(user, token)
        
        return Response({
            'message': 'Registration successful. Please check your email to verify your account.',
            'user': UserSerializer(user).data,
            'verification_token': str(token.token)  # Remove in production
        }, status=status.HTTP_201_CREATED)


class VerifyEmailView(APIView):
    """
    POST: Verify email with token
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = EmailVerificationSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        token_uuid = serializer.validated_data['token']
        
        try:
            token = EmailVerificationToken.objects.get(token=token_uuid)
        except EmailVerificationToken.DoesNotExist:
            return Response(
                {'error': 'Invalid verification token.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if not token.is_valid():
            return Response(
                {'error': 'Verification token has expired or been used.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Mark token as used and verify user
        token.used = True
        token.save()
        
        user = token.user
        user.is_email_verified = True
        user.save()
        
        return Response({
            'message': 'Email verified successfully. You can now log in.',
            'user': UserSerializer(user).data
        }, status=status.HTTP_200_OK)


class LoginView(APIView):
    """
    POST: Login with email and password
    Returns JWT access and refresh tokens
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = LoginSerializer(data=request.data, context={'request': request})
        serializer.is_valid(raise_exception=True)
        
        user = serializer.validated_data['user']
        
        # Generate JWT tokens
        refresh = RefreshToken.for_user(user)
        
        return Response({
            'message': 'Login successful.',
            'user': UserSerializer(user).data,
            'tokens': {
                'refresh': str(refresh),
                'access': str(refresh.access_token),
            }
        }, status=status.HTTP_200_OK)


class RefreshTokenView(APIView):
    """
    POST: Refresh access token using refresh token
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        refresh_token = request.data.get('refresh')
        
        if not refresh_token:
            return Response(
                {'error': 'Refresh token is required.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            refresh = RefreshToken(refresh_token)
            return Response({
                'access': str(refresh.access_token)
            }, status=status.HTTP_200_OK)
        except Exception as e:
            return Response(
                {'error': 'Invalid or expired refresh token.'},
                status=status.HTTP_401_UNAUTHORIZED
            )


class LogoutView(APIView):
    """
    POST: Logout (blacklist refresh token)
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        try:
            refresh_token = request.data.get('refresh')
            if refresh_token:
                token = RefreshToken(refresh_token)
                token.blacklist()
            return Response(
                {'message': 'Logout successful.'},
                status=status.HTTP_200_OK
            )
        except Exception:
            return Response(
                {'error': 'Invalid token.'},
                status=status.HTTP_400_BAD_REQUEST
            )


class PasswordResetRequestView(APIView):
    """
    POST: Request password reset email
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PasswordResetRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        email = serializer.validated_data['email']
        
        try:
            user = User.objects.get(email=email)
            
            # Create reset token
            token = PasswordResetToken.objects.create(user=user)
            
            # TODO: Send reset email (Task 1.3)
            # send_password_reset_email(user, token)
            
            return Response({
                'message': 'Password reset email sent. Please check your email.',
                'reset_token': str(token.token)  # Remove in production
            }, status=status.HTTP_200_OK)
        except User.DoesNotExist:
            # Don't reveal if email exists
            return Response({
                'message': 'If that email exists, a password reset link has been sent.'
            }, status=status.HTTP_200_OK)


class PasswordResetConfirmView(APIView):
    """
    POST: Reset password with token
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PasswordResetConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        token_uuid = serializer.validated_data['token']
        new_password = serializer.validated_data['password']
        
        try:
            token = PasswordResetToken.objects.get(token=token_uuid)
        except PasswordResetToken.DoesNotExist:
            return Response(
                {'error': 'Invalid reset token.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if not token.is_valid():
            return Response(
                {'error': 'Reset token has expired or been used.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Reset password
        user = token.user
        user.set_password(new_password)
        user.save()
        
        # Mark token as used
        token.used = True
        token.save()
        
        return Response({
            'message': 'Password reset successful. You can now log in with your new password.'
        }, status=status.HTTP_200_OK)


class UserProfileView(generics.RetrieveUpdateAPIView):
    """
    GET: Get current user profile
    PATCH: Update current user profile
    """
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_object(self):
        return self.request.user
    
    def get_serializer_class(self):
        if self.request.method == 'PATCH':
            return UserProfileUpdateSerializer
        return UserSerializer
```

