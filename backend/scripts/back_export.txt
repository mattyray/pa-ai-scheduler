# TOTETAXI - BACKEND CODE SNAPSHOT
# AUTO-GENERATED - CODE FILES ONLY
# Created: 2025-11-08 17:16:49
# Total files: 88
# ðŸ”’ SECURITY: .env files excluded (contain secrets)
# ðŸ“‹ INCLUDES: All Django apps, migrations, configuration
# Apps: accounts (STAFF), bookings, customers, logistics, payments, services
# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery
# Integration: S3 storage, SES email, mocked Stripe/Onfleet


# ========================= CONFIGURATION & ROOT FILES =========================


# ==== .dockerignore ====

```
# Git
.git
.gitignore

# Docker
.docker
Dockerfile
Dockerfile.prod
docker-compose*

# Python
__pycache__
*.pyc
*.pyo
*.pyd
.Python
venv/
.venv/
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.pytest_cache
.cache
htmlcov
.mypy_cache
.dmypy.json
dmypy.json

# IDEs
.vscode
.idea
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs
*.log
npm-debug.log*

# Environment
.env
.env.local
.env.development
.env.production

# Database
*.sqlite3
db.sqlite3

# Media files
media/

# Static files (will be collected in container)
staticfiles/

# Node (if any)
node_modules
npm-debug.log
```

# ==== Dockerfile ====

```dockerfile
FROM python:3.11-slim

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PYTHONPATH=/app \
    PORT=8000

# Set work directory
WORKDIR /app

# Install system dependencies
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
        postgresql-client \
        build-essential \
        libpq-dev \
        curl \
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . /app/

# Create directories for logs and static files
RUN mkdir -p /app/logs /app/staticfiles /app/media

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD curl -f http://localhost:8000/ || exit 1

CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
```

# ==== docker-compose.yml ====

```yaml
name: pa-scheduler-backend

services:
  # PostgreSQL Database - PORT 5436
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: pa_scheduler
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5436:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis for Celery - PORT 6383
  redis:
    image: redis:7-alpine
    ports:
      - "6383:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Django Backend - PORT 8006
  web:
    build: .
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    ports:
      - "8006:8000"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/pa_scheduler
      - REDIS_URL=redis://redis:6379/0

  # Celery Worker
  celery:
    build: .
    command: celery -A config worker -l info
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/pa_scheduler
      - REDIS_URL=redis://redis:6379/0

  # Celery Beat Scheduler
  celery-beat:
    build: .
    command: celery -A config beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler
    volumes:
      - .:/app
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    env_file:
      - .env
    environment:
      - DEBUG=True
      - DATABASE_URL=postgres://postgres:postgres@db:5432/pa_scheduler
      - REDIS_URL=redis://redis:6379/0

volumes:
  postgres_data:
  static_volume:
  media_volume:
  redis_data:
```

# ==== manage.py ====

```python
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
```

# ==== project_structure.txt ====

```
.
â”œâ”€â”€ apps
â”‚Â Â  â”œâ”€â”€ ai
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ migrations
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ admin.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ apps.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests.py
â”‚Â Â  â”‚Â Â  â””â”€â”€ views.py
â”‚Â Â  â”œâ”€â”€ schedules
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ migrations
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 0001_initial.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ admin.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ apps.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ consumers.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ routing.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ serializers.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ utils.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ views.py
â”‚Â Â  â”‚Â Â  â””â”€â”€ websocket_utils.py
â”‚Â Â  â”œâ”€â”€ shifts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ migrations
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 0001_initial.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ templates
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ emails
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ new_request_admin.html
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ new_request_admin.txt
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ shift_approved.html
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ shift_approved.txt
â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ shift_rejected.html
â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ shift_rejected.txt
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ admin.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ apps.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ serializers.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tasks.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ tests.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  â”‚Â Â  â””â”€â”€ views.py
â”‚Â Â  â””â”€â”€ users
â”‚Â Â      â”œâ”€â”€ migrations
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ 0001_initial.py
â”‚Â Â      â”‚Â Â  â””â”€â”€ 0002_emailverificationtoken_passwordresettoken.py
â”‚Â Â      â”œâ”€â”€ __init__.py
â”‚Â Â      â”œâ”€â”€ admin.py
â”‚Â Â      â”œâ”€â”€ apps.py
â”‚Â Â      â”œâ”€â”€ models.py
â”‚Â Â      â”œâ”€â”€ serializers.py
â”‚Â Â      â”œâ”€â”€ tests.py
â”‚Â Â      â”œâ”€â”€ urls.py
â”‚Â Â      â””â”€â”€ views.py
â”œâ”€â”€ config
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ asgi.py
â”‚Â Â  â”œâ”€â”€ celery.py
â”‚Â Â  â”œâ”€â”€ settings.py
â”‚Â Â  â”œâ”€â”€ urls.py
â”‚Â Â  â””â”€â”€ wsgi.py
â”œâ”€â”€ logs
â”œâ”€â”€ scripts
â”‚Â Â  â”œâ”€â”€ back_export.py
â”‚Â Â  â””â”€â”€ back_export.txt
â”œâ”€â”€ .dockerignore
â”œâ”€â”€ .env.example
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ manage.py
â”œâ”€â”€ project_structure.txt
â””â”€â”€ requirements.txt

15 directories, 64 files
```

# ==== requirements.txt ====

```
# Django Core - Django 5.2 LTS
Django==5.2.7
djangorestframework==3.16.1
django-cors-headers==4.6.0

# Database
psycopg2-binary==2.9.10
dj-database-url==2.2.0

# Authentication
djangorestframework-simplejwt==5.4.0

# Async Tasks
celery==5.5.3
redis==5.2.0
django-celery-beat==2.8.0

# WebSockets
channels==4.3.1
channels-redis==4.2.1
daphne==4.2.1

# Email
boto3==1.35.80

# AI
openai==2.6.1

# Server
gunicorn==23.0.0

# Utilities
python-dotenv==1.0.1
Pillow==11.0.0
```

# ========================= DJANGO PROJECT SETTINGS (config/) =========================


# ==== config/__init__.py ====

```python
# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = ('celery_app',)
```

# ==== config/asgi.py ====

```python
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

django_asgi_app = get_asgi_application()

# Import after Django is set up
from apps.schedules.routing import websocket_urlpatterns

application = ProtocolTypeRouter({
    "http": django_asgi_app,
    "websocket": AuthMiddlewareStack(
        URLRouter(
            websocket_urlpatterns
        )
    ),
})
```

# ==== config/celery.py ====

```python
import os
from celery import Celery
from celery.schedules import crontab

# Set the default Django settings module
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

app = Celery('config')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django apps.
app.autodiscover_tasks()

# Celery Beat Schedule
app.conf.beat_schedule = {
    'check-upcoming-coverage': {
        'task': 'apps.ai.tasks.check_upcoming_coverage',
        'schedule': crontab(hour=6, minute=0),  # Run daily at 6 AM
    },
    'calculate-pa-patterns': {
        'task': 'apps.users.tasks.calculate_all_pa_patterns',
        'schedule': crontab(day_of_week=1, hour=2, minute=0),  # Run weekly Monday 2 AM
    },
}

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')
```

# ==== config/settings.py ====

```python
import os
from pathlib import Path
from datetime import timedelta
import dj_database_url

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.environ.get('SECRET_KEY', 'django-insecure-dev-key-change-this-in-production')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.environ.get('DEBUG', 'True') == 'True'

ALLOWED_HOSTS = os.environ.get('ALLOWED_HOSTS', 'localhost,127.0.0.1').split(',')

# Application definition
INSTALLED_APPS = [
    'daphne',  # Must be first for channels
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third-party apps
    'rest_framework',
    'rest_framework_simplejwt',
    'rest_framework_simplejwt.token_blacklist',  # Add this line
    'corsheaders',
    'channels',
    'django_celery_beat',
    
    # Local apps
    'apps.users',
    'apps.schedules',
    'apps.shifts',
    'apps.coverage',
    'apps.ai',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'
ASGI_APPLICATION = 'config.asgi.application'

# Database
DATABASES = {
    'default': dj_database_url.config(
        default=os.environ.get('DATABASE_URL', 'postgres://postgres:postgres@localhost:5436/pa_scheduler'),
        conn_max_age=600
    )
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'America/New_York'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Custom User Model
AUTH_USER_MODEL = 'users.User'

# REST Framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 50,
}

# JWT Settings
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'UPDATE_LAST_LOGIN': True,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
}

# Add to INSTALLED_APPS

# CORS Settings
CORS_ALLOWED_ORIGINS = os.environ.get(
    'CORS_ALLOWED_ORIGINS',
    'http://localhost:3000'
).split(',')

CORS_ALLOW_CREDENTIALS = True

# Celery Configuration
CELERY_BROKER_URL = os.environ.get('REDIS_URL', 'redis://localhost:6383/0')
CELERY_RESULT_BACKEND = os.environ.get('REDIS_URL', 'redis://localhost:6383/0')
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE

# Channels (WebSockets)
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            'hosts': [os.environ.get('REDIS_URL', 'redis://localhost:6383/0')],
        },
    },
}

# Email Configuration (Amazon SES)
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend' if not DEBUG else 'django.core.mail.backends.console.EmailBackend'
EMAIL_HOST = 'email-smtp.us-east-1.amazonaws.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = os.environ.get('AWS_ACCESS_KEY_ID', '')
EMAIL_HOST_PASSWORD = os.environ.get('AWS_SECRET_ACCESS_KEY', '')
DEFAULT_FROM_EMAIL = os.environ.get('DEFAULT_FROM_EMAIL', 'noreply@example.com')

# OpenAI
OPENAI_API_KEY = os.environ.get('OPENAI_API_KEY', '')

# Frontend URL
FRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')
# Logging

# Ensure logs directory exists
LOGS_DIR = BASE_DIR / 'logs'
LOGS_DIR.mkdir(exist_ok=True)

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': LOGS_DIR / 'django.log',
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': os.environ.get('DJANGO_LOG_LEVEL', 'INFO'),
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
```

# ==== config/urls.py ====

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/auth/', include('apps.users.urls')),
    path('api/schedule-periods/', include('apps.schedules.urls')),
    path('api/shifts/', include('apps.shifts.urls')),
    path('api/', include('apps.schedules.urls')),
]
```

# ==== config/wsgi.py ====

```python
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
```

# ========================= SCRIPTS & UTILITIES =========================


# ==== scripts/back_export.py ====

```python
#!/usr/bin/env python3
"""
ToteTaxi Backend Export - Code Files Only
"""
import os
from pathlib import Path
from datetime import datetime

def get_file_content(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        return f"# Error reading file: {e}"

def should_include_file(file_path, base_dir):
    """Smart file inclusion rules for ToteTaxi Backend - Code Only"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Skip patterns - SECURITY: Handle .env files separately
    skip_patterns = [
        '__pycache__', '.pyc', '.git/', '.pytest_cache/', 'htmlcov/',
        'staticfiles/', 'media/', 'logs/', '.coverage', 'db.sqlite3',
        'back_export.txt', 'totetaxi_backend_snapshot.txt',
        '.DS_Store', '*.swp', '*.swo',
        'README.md', 'CHANGELOG.md'  # Skip documentation files
    ]
    
    if any(pattern in path_str for pattern in skip_patterns):
        return False
    
    # SECURITY: Skip .env files (contain secrets)
    if file_path.name.startswith('.env'):
        return False
    
    # Include patterns - Code files only
    include_extensions = {'.py', '.txt', '.yml', '.yaml', '.toml', '.sh', '.ini', '.conf'}
    include_files = {
        'Dockerfile', 'Dockerfile.dev', '.dockerignore', '.gitignore', 
        'manage.py', 'docker-compose.yml', 'docker-compose.prod.yml',
        'gunicorn.conf.py', 'pytest.ini', 'requirements.txt'
    }
    
    return (
        file_path.suffix in include_extensions or 
        file_path.name in include_files
    )

def categorize_file(file_path, base_dir):
    """Auto-categorize files for ToteTaxi structure"""
    rel_path = file_path.relative_to(base_dir)
    path_str = str(rel_path)
    
    # Configuration files (root level)
    if (rel_path.parent == Path('.') or 
        file_path.name in ['manage.py', 'requirements.txt', 'gunicorn.conf.py', 'pytest.ini']):
        return 'config'
    
    # ToteTaxi Django apps - UPDATED to 6 apps only
    totetaxi_apps = [
        'accounts/', 'bookings/', 'customers/', 
        'logistics/', 'payments/', 'services/'
    ]
    if any(f'apps/{app}' in path_str for app in totetaxi_apps):
        return 'apps'
    
    # Django project settings (config/ directory)
    if 'config/' in path_str:
        return 'project'
    
    # Scripts directory
    if 'scripts/' in path_str:
        return 'scripts'
    
    # Everything else
    return 'other'

def main():
    backend_dir = Path(__file__).parent.parent
    output_file = backend_dir / 'scripts' / 'back_export.txt'
    
    print(f"ðŸ” Auto-discovering ToteTaxi backend files in: {backend_dir}")
    
    # Auto-discover all relevant files
    all_files = []
    for file_path in backend_dir.rglob('*'):
        if file_path.is_file() and should_include_file(file_path, backend_dir):
            all_files.append(file_path)
    
    # Categorize files
    categories = {
        'config': [],
        'project': [],
        'apps': [],
        'scripts': [],
        'other': []
    }
    
    for file_path in all_files:
        category = categorize_file(file_path, backend_dir)
        categories[category].append(file_path)
    
    # Sort within categories
    for category in categories:
        categories[category].sort()
    
    print(f"ðŸ“Š Found {len(all_files)} files:")
    for cat, files in categories.items():
        if files:
            print(f"  - {cat}: {len(files)} files")
    
    # Generate snapshot
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# TOTETAXI - BACKEND CODE SNAPSHOT\n")
        f.write("# AUTO-GENERATED - CODE FILES ONLY\n")
        f.write(f"# Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# Total files: {len(all_files)}\n")
        f.write("# ðŸ”’ SECURITY: .env files excluded (contain secrets)\n")
        f.write("# ðŸ“‹ INCLUDES: All Django apps, migrations, configuration\n")
        f.write("# Apps: accounts (STAFF), bookings, customers, logistics, payments, services\n")  # UPDATED
        f.write("# Tech Stack: Django 5.2.5, DRF 3.16.1, PostgreSQL, Redis, Celery\n")
        f.write("# Integration: S3 storage, SES email, mocked Stripe/Onfleet\n\n\n")
        
        # Output by category
        section_names = {
            'config': 'CONFIGURATION & ROOT FILES',
            'project': 'DJANGO PROJECT SETTINGS (config/)',
            'apps': 'DJANGO APPLICATIONS (apps/)',
            'scripts': 'SCRIPTS & UTILITIES',
            'other': 'OTHER FILES'
        }
        
        for category, section_name in section_names.items():
            if categories[category]:
                f.write("# " + "="*25 + f" {section_name} " + "="*25 + "\n\n\n")
                
                for file_path in categories[category]:
                    rel_path = file_path.relative_to(backend_dir)
                    f.write(f"# ==== {rel_path} ====\n\n")
                    
                    # Smart syntax highlighting
                    if file_path.suffix == '.py':
                        f.write("```python\n")
                    elif file_path.suffix in ['.yml', '.yaml']:
                        f.write("```yaml\n")
                    elif file_path.suffix == '.toml':
                        f.write("```toml\n")
                    elif file_path.suffix == '.sh':
                        f.write("```bash\n")
                    elif file_path.name in ['Dockerfile', 'Dockerfile.dev']:
                        f.write("```dockerfile\n")
                    elif file_path.suffix == '.ini':
                        f.write("```ini\n")
                    else:
                        f.write("```\n")
                    
                    content = get_file_content(file_path)
                    f.write(content)
                    if not content.endswith('\n'):
                        f.write('\n')
                    f.write("```\n\n")
    
    print(f"âœ… Auto-generated ToteTaxi backend snapshot: {output_file}")
    print("ðŸ”’ SECURITY: .env files excluded (contain secrets)")
    print("ðŸ“‹ INCLUDES: All 6 Django apps with migrations")  # UPDATED
    print("ðŸ—ï¸  STRUCTURE: accounts (staff), bookings, customers, logistics, payments, services")  # UPDATED
    print("ðŸ³ DOCKER: Configuration and compose files included")
    print("ðŸ“ CODE ONLY: Documentation files excluded")

if __name__ == "__main__":
    main()
```

# ========================= OTHER FILES =========================


# ==== apps/ai/__init__.py ====

```python

```

# ==== apps/ai/admin.py ====

```python
from django.contrib import admin

# Register your models here.
```

# ==== apps/ai/apps.py ====

```python
from django.apps import AppConfig


class AiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.ai'
```

# ==== apps/ai/migrations/__init__.py ====

```python

```

# ==== apps/ai/models.py ====

```python
from django.db import models

# Create your models here.
```

# ==== apps/ai/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/ai/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/coverage/__init__.py ====

```python

```

# ==== apps/coverage/admin.py ====

```python
from django.contrib import admin
from .models import CriticalTimeCoverage, WeeklyCoverage


@admin.register(CriticalTimeCoverage)
class CriticalTimeCoverageAdmin(admin.ModelAdmin):
    list_display = ['date', 'morning_covered', 'evening_covered', 'coverage_status', 'updated_at']
    list_filter = ['morning_covered', 'evening_covered', 'date']
    search_fields = ['date']
    readonly_fields = ['updated_at']
    date_hierarchy = 'date'
    
    fieldsets = (
        ('Date', {
            'fields': ('date',)
        }),
        ('Coverage Status', {
            'fields': ('morning_covered', 'evening_covered', 'morning_shift', 'evening_shift')
        }),
        ('Metadata', {
            'fields': ('updated_at',),
            'classes': ('collapse',)
        }),
    )
    
    def coverage_status(self, obj):
        """Display coverage status with icon"""
        if obj.is_fully_covered:
            return 'âœ… Complete'
        elif obj.morning_covered or obj.evening_covered:
            return 'âš ï¸ Partial'
        return 'âŒ None'
    coverage_status.short_description = 'Coverage Status'


@admin.register(WeeklyCoverage)
class WeeklyCoverageAdmin(admin.ModelAdmin):
    list_display = ['pa', 'week_start_date', 'schedule_period', 'total_hours', 'exceeds_limit', 'updated_at']
    list_filter = ['exceeds_limit', 'schedule_period', 'week_start_date']
    search_fields = ['pa__email', 'pa__first_name', 'pa__last_name']
    readonly_fields = ['updated_at']
    date_hierarchy = 'week_start_date'
    
    fieldsets = (
        ('Week Information', {
            'fields': ('schedule_period', 'pa', 'week_start_date')
        }),
        ('Hours', {
            'fields': ('total_hours', 'exceeds_limit')
        }),
        ('Metadata', {
            'fields': ('updated_at',),
            'classes': ('collapse',)
        }),
    )
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related(
            'schedule_period', 'pa'
        )
```

# ==== apps/coverage/apps.py ====

```python
from django.apps import AppConfig


class CoverageConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.coverage'
    
    def ready(self):
        import apps.coverage.signals  # noqa
```

# ==== apps/coverage/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 18:20

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('schedules', '0001_initial'),
        ('shifts', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CriticalTimeCoverage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField(db_index=True, unique=True)),
                ('morning_covered', models.BooleanField(default=False)),
                ('evening_covered', models.BooleanField(default=False)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('evening_shift', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='covers_evening', to='shifts.shiftrequest')),
                ('morning_shift', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='covers_morning', to='shifts.shiftrequest')),
            ],
            options={
                'verbose_name': 'Critical Time Coverage',
                'verbose_name_plural': 'Critical Time Coverage',
                'db_table': 'critical_time_coverage',
                'ordering': ['date'],
            },
        ),
        migrations.CreateModel(
            name='WeeklyCoverage',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('week_start_date', models.DateField(db_index=True)),
                ('total_hours', models.DecimalField(decimal_places=2, default=0, max_digits=5)),
                ('exceeds_limit', models.BooleanField(default=False)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('pa', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='weekly_hours', to=settings.AUTH_USER_MODEL)),
                ('schedule_period', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='weekly_coverage', to='schedules.scheduleperiod')),
            ],
            options={
                'verbose_name': 'Weekly Coverage',
                'verbose_name_plural': 'Weekly Coverage',
                'db_table': 'weekly_coverage',
                'ordering': ['week_start_date', 'pa'],
                'unique_together': {('schedule_period', 'pa', 'week_start_date')},
            },
        ),
    ]
```

# ==== apps/coverage/migrations/__init__.py ====

```python

```

# ==== apps/coverage/models.py ====

```python
# apps/coverage/models.py
from django.db import models
from django.conf import settings


class CriticalTimeCoverage(models.Model):
    """
    Tracks whether critical times (6-9 AM morning, 9-10 PM evening) are covered for each date.
    Updated automatically when shifts are approved/rejected/deleted.
    """
    date = models.DateField(unique=True, db_index=True)
    morning_covered = models.BooleanField(default=False)  # 6-9 AM
    evening_covered = models.BooleanField(default=False)  # 9-10 PM
    morning_shift = models.ForeignKey(
        'shifts.ShiftRequest', 
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='covers_morning'
    )
    evening_shift = models.ForeignKey(
        'shifts.ShiftRequest',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='covers_evening'
    )
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'critical_time_coverage'
        ordering = ['date']
        verbose_name = 'Critical Time Coverage'
        verbose_name_plural = 'Critical Time Coverage'
    
    def __str__(self):
        status = []
        if self.morning_covered:
            status.append('Morning âœ…')
        else:
            status.append('Morning âŒ')
        if self.evening_covered:
            status.append('Evening âœ…')
        else:
            status.append('Evening âŒ')
        return f"{self.date} - {' | '.join(status)}"
    
    @property
    def is_fully_covered(self):
        """Returns True if both morning and evening are covered"""
        return self.morning_covered and self.evening_covered
    
    @property
    def coverage_status(self):
        """Returns coverage status: 'complete', 'partial', or 'none'"""
        if self.morning_covered and self.evening_covered:
            return 'complete'
        elif self.morning_covered or self.evening_covered:
            return 'partial'
        return 'none'


class WeeklyCoverage(models.Model):
    """
    Tracks total hours worked by each PA per week within a schedule period.
    Used for overtime warnings and weekly limit checks.
    """
    schedule_period = models.ForeignKey(
        'schedules.SchedulePeriod', 
        on_delete=models.CASCADE,
        related_name='weekly_coverage'
    )
    pa = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE,
        related_name='weekly_hours'
    )
    week_start_date = models.DateField(db_index=True)  # Monday of the week
    total_hours = models.DecimalField(max_digits=5, decimal_places=2, default=0)
    exceeds_limit = models.BooleanField(default=False)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'weekly_coverage'
        unique_together = ['schedule_period', 'pa', 'week_start_date']
        ordering = ['week_start_date', 'pa']
        verbose_name = 'Weekly Coverage'
        verbose_name_plural = 'Weekly Coverage'
    
    def __str__(self):
        warning = " âš ï¸ OVERTIME" if self.exceeds_limit else ""
        return f"{self.pa.get_full_name()} - Week of {self.week_start_date}: {self.total_hours}h{warning}"
    
    def check_exceeds_limit(self, max_hours=40):
        """
        Check if total hours exceed the limit.
        max_hours can be passed from PA's custom limit or default 40.
        """
        self.exceeds_limit = self.total_hours > max_hours
        return self.exceeds_limit
```

# ==== apps/coverage/signals.py ====

```python
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from apps.shifts.models import ShiftRequest
from .utils import update_coverage_for_shift


@receiver(post_save, sender=ShiftRequest)
def shift_saved(sender, instance, **kwargs):
    """
    Update coverage whenever a shift is saved.
    Only update for approved shifts.
    """
    if instance.status == 'APPROVED':
        update_coverage_for_shift(instance)


@receiver(post_delete, sender=ShiftRequest)
def shift_deleted(sender, instance, **kwargs):
    """
    Update coverage when a shift is deleted.
    """
    if instance.status == 'APPROVED':
        update_coverage_for_shift(instance)
```

# ==== apps/coverage/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/coverage/utils.py ====

```python
from datetime import time, timedelta
from apps.shifts.models import ShiftRequest
from .models import CriticalTimeCoverage, WeeklyCoverage


def calculate_critical_coverage(date):
    """
    Calculate and update critical time coverage for a specific date.
    
    Critical Times:
    - Morning: 6:00 AM - 9:00 AM (must cover full 3 hours)
    - Evening: 9:00 PM - 10:00 PM (must cover full 1 hour)
    
    Handles overnight shifts correctly (when end_time < start_time).
    
    Args:
        date: datetime.date object
    
    Returns:
        CriticalTimeCoverage instance
    """
    coverage, created = CriticalTimeCoverage.objects.get_or_create(date=date)
    
    shifts = ShiftRequest.objects.filter(
        date=date,
        status='APPROVED'
    )
    
    coverage.morning_covered = False
    coverage.evening_covered = False
    coverage.morning_shift = None
    coverage.evening_shift = None
    
    for shift in shifts:
        is_overnight = shift.end_time < shift.start_time
        
        if is_overnight:
            if shift.start_time <= time(21, 0):
                coverage.evening_covered = True
                coverage.evening_shift = shift
            
            if shift.end_time >= time(9, 0):
                coverage.morning_covered = True
                coverage.morning_shift = shift
        else:
            if shift.start_time <= time(6, 0) and shift.end_time >= time(9, 0):
                coverage.morning_covered = True
                coverage.morning_shift = shift
            
            if shift.start_time <= time(21, 0) and shift.end_time >= time(22, 0):
                coverage.evening_covered = True
                coverage.evening_shift = shift
    
    coverage.save()
    return coverage


def calculate_weekly_hours(pa, week_start_date):
    """
    Calculate and update weekly hours for a PA.
    
    Args:
        pa: User instance (PA)
        week_start_date: datetime.date (Monday of the week)
    
    Returns:
        WeeklyCoverage instance
    """
    from apps.users.models import User
    
    if week_start_date.weekday() != 0:
        week_start_date = week_start_date - timedelta(days=week_start_date.weekday())
    
    week_end_date = week_start_date + timedelta(days=6)
    
    shifts = ShiftRequest.objects.filter(
        requested_by=pa,
        status='APPROVED',
        date__gte=week_start_date,
        date__lte=week_end_date
    )
    
    total_hours = sum(shift.duration_hours for shift in shifts)
    
    max_hours = 40
    if hasattr(pa, 'pa_profile'):
        max_hours = pa.pa_profile.max_hours_per_week
    
    schedule_period = None
    if shifts.exists():
        schedule_period = shifts.first().schedule_period
    
    if schedule_period:
        coverage, created = WeeklyCoverage.objects.get_or_create(
            schedule_period=schedule_period,
            pa=pa,
            week_start_date=week_start_date,
            defaults={'total_hours': total_hours}
        )
        
        if not created:
            coverage.total_hours = total_hours
        
        coverage.check_exceeds_limit(max_hours)
        coverage.save()
        
        return coverage
    
    return None


def get_monday_of_week(date):
    """
    Get the Monday of the week for a given date.
    
    Args:
        date: datetime.date
    
    Returns:
        datetime.date (Monday)
    """
    return date - timedelta(days=date.weekday())


def update_coverage_for_shift(shift):
    """
    Update both critical time coverage and weekly hours when a shift changes.
    
    Args:
        shift: ShiftRequest instance
    """
    calculate_critical_coverage(shift.date)
    
    week_start = get_monday_of_week(shift.date)
    calculate_weekly_hours(shift.requested_by, week_start)
```

# ==== apps/coverage/views.py ====

```python
from django.shortcuts import render

# Create your views here.
```

# ==== apps/schedules/__init__.py ====

```python

```

# ==== apps/schedules/admin.py ====

```python
from django.contrib import admin
from .models import SchedulePeriod


@admin.register(SchedulePeriod)
class SchedulePeriodAdmin(admin.ModelAdmin):
    list_display = ['name', 'start_date', 'end_date', 'status', 'created_by', 'created_at']
    list_filter = ['status', 'created_at']
    search_fields = ['name']
    readonly_fields = ['created_at', 'updated_at']
    
    fieldsets = (
        ('Period Information', {
            'fields': ('name', 'start_date', 'end_date', 'status')
        }),
        ('Metadata', {
            'fields': ('created_by', 'created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
```

# ==== apps/schedules/apps.py ====

```python
from django.apps import AppConfig


class SchedulesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.schedules'
```

# ==== apps/schedules/consumers.py ====

```python
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth.models import AnonymousUser
from rest_framework_simplejwt.tokens import AccessToken
from rest_framework_simplejwt.exceptions import InvalidToken, TokenError
from apps.users.models import User


class ScheduleConsumer(AsyncWebsocketConsumer):
    """
    WebSocket consumer for real-time schedule updates.
    
    URL: ws://localhost:8006/ws/schedule/<period_id>/
    
    Events broadcast to this consumer:
    - shift.requested (new shift request submitted)
    - shift.approved (shift approved)
    - shift.rejected (shift rejected)
    - shift.updated (shift edited)
    - shift.deleted (shift deleted)
    - coverage.alert (coverage status changed)
    - period.finalized (period finalized)
    """
    
    async def connect(self):
        """Handle WebSocket connection"""
        self.period_id = self.scope['url_route']['kwargs']['period_id']
        self.room_group_name = f'schedule_{self.period_id}'
        
        # Authenticate user via JWT token
        user = await self.get_user_from_token()
        
        if user is None or user.is_anonymous:
            # Reject connection if not authenticated
            await self.close(code=4001)
            return
        
        self.scope['user'] = user
        
        # Join room group
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # Send connection confirmation
        await self.send(text_data=json.dumps({
            'type': 'connection.established',
            'message': f'Connected to schedule period {self.period_id}',
            'user': {
                'id': user.id,
                'email': user.email,
                'role': user.role
            }
        }))
    
    async def disconnect(self, close_code):
        """Handle WebSocket disconnection"""
        # Leave room group
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
    
    async def receive(self, text_data):
        """
        Receive message from WebSocket (client -> server)
        Currently not used, but available for future bidirectional features
        """
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            
            # Handle ping/pong for connection keep-alive
            if message_type == 'ping':
                await self.send(text_data=json.dumps({
                    'type': 'pong',
                    'timestamp': data.get('timestamp')
                }))
        except json.JSONDecodeError:
            await self.send(text_data=json.dumps({
                'type': 'error',
                'message': 'Invalid JSON'
            }))
    
    # Event handlers (server -> client broadcasts)
    
    async def shift_requested(self, event):
        """Broadcast when a new shift is requested"""
        await self.send(text_data=json.dumps({
            'type': 'shift.requested',
            'shift': event['shift'],
            'message': event.get('message', 'New shift request submitted')
        }))
    
    async def shift_approved(self, event):
        """Broadcast when a shift is approved"""
        await self.send(text_data=json.dumps({
            'type': 'shift.approved',
            'shift': event['shift'],
            'message': event.get('message', 'Shift approved')
        }))
    
    async def shift_rejected(self, event):
        """Broadcast when a shift is rejected"""
        await self.send(text_data=json.dumps({
            'type': 'shift.rejected',
            'shift': event['shift'],
            'message': event.get('message', 'Shift rejected')
        }))
    
    async def shift_updated(self, event):
        """Broadcast when a shift is updated"""
        await self.send(text_data=json.dumps({
            'type': 'shift.updated',
            'shift': event['shift'],
            'changes': event.get('changes', {}),
            'message': event.get('message', 'Shift updated')
        }))
    
    async def shift_deleted(self, event):
        """Broadcast when a shift is deleted"""
        await self.send(text_data=json.dumps({
            'type': 'shift.deleted',
            'shift_id': event['shift_id'],
            'message': event.get('message', 'Shift deleted')
        }))
    
    async def coverage_alert(self, event):
        """Broadcast when coverage status changes"""
        await self.send(text_data=json.dumps({
            'type': 'coverage.alert',
            'date': event['date'],
            'coverage': event['coverage'],
            'message': event.get('message', 'Coverage updated')
        }))
    
    async def period_finalized(self, event):
        """Broadcast when period is finalized"""
        await self.send(text_data=json.dumps({
            'type': 'period.finalized',
            'period': event['period'],
            'message': event.get('message', 'Schedule period finalized')
        }))
    
    # Helper methods
    
    @database_sync_to_async
    def get_user_from_token(self):
        """
        Authenticate user from JWT token in query string.
        WebSocket URL: ws://localhost:8006/ws/schedule/1/?token=<jwt_token>
        """
        try:
            # Get token from query string
            query_string = self.scope.get('query_string', b'').decode()
            params = dict(param.split('=') for param in query_string.split('&') if '=' in param)
            token = params.get('token')
            
            if not token:
                return AnonymousUser()
            
            # Validate token
            access_token = AccessToken(token)
            user_id = access_token['user_id']
            
            # Get user
            user = User.objects.get(id=user_id)
            return user
            
        except (InvalidToken, TokenError, User.DoesNotExist, KeyError, ValueError):
            return AnonymousUser()
```

# ==== apps/schedules/management/__init__.py ====

```python

```

# ==== apps/schedules/management/commands/__init__.py ====

```python

```

# ==== apps/schedules/management/commands/add_pending_requests.py ====

```python
from django.core.management.base import BaseCommand
from django.utils import timezone
from datetime import datetime, time, timedelta
from apps.users.models import User, PAProfile
from apps.schedules.models import SchedulePeriod
from apps.shifts.models import ShiftRequest
from decimal import Decimal


class Command(BaseCommand):
    help = 'Add pending shift requests to existing test data'

    def handle(self, *args, **kwargs):
        self.stdout.write('Adding pending shift requests...\n')
        
        # Get existing PAs
        pa1 = User.objects.filter(email='sarah.johnson@example.com').first()
        pa2 = User.objects.filter(email='michael.chen@example.com').first()
        pa3 = User.objects.filter(email='emily.davis@example.com').first()
        
        if not pa1 or not pa2:
            self.stdout.write(self.style.ERROR('Test PAs not found. Run create_test_data first.'))
            return
        
        if not pa3:
            pa3 = User.objects.create(
                email='emily.davis@example.com',
                username='emily.davis',
                first_name='Emily',
                last_name='Davis',
                phone_number='+1-555-0103',
                role='PA',
                is_email_verified=True,
                is_active=True
            )
            pa3.set_password('testpass123')
            pa3.save()
            
            PAProfile.objects.get_or_create(
                user=pa3,
                defaults={
                    'max_hours_per_week': 30,
                    'preferred_start_time': time(6, 0),
                    'preferred_end_time': time(18, 0)
                }
            )
            self.stdout.write(self.style.SUCCESS(f'âœ“ Created new PA: {pa3.get_full_name()}'))
        else:
            self.stdout.write(f'âœ“ Found existing PA: {pa3.get_full_name()}')
        
        # Get periods
        period1 = SchedulePeriod.objects.filter(start_date=datetime(2025, 11, 2).date()).first()
        period2 = SchedulePeriod.objects.filter(start_date=datetime(2025, 11, 9).date()).first()
        
        if not period1 or not period2:
            self.stdout.write(self.style.ERROR('Test periods not found. Run create_test_data first.'))
            return
        
        self.stdout.write(self.style.WARNING('\nCreating PENDING requests...\n'))
        
        # Week 1 - PENDING requests
        self.stdout.write('Week 1 (Nov 2-8):')
        
        # Sarah - extra morning Tuesday
        self.create_pending_request(
            period1, pa1, 
            period1.start_date + timedelta(days=1),
            time(6, 0), time(12, 0),
            "Need extra hours this week, can cover morning"
        )
        
        # Michael - afternoon Sunday  
        self.create_pending_request(
            period1, pa2,
            period1.start_date + timedelta(days=5),
            time(14, 0), time(20, 0),
            "Available for afternoon coverage"
        )
        
        # Emily - midday Thursday
        self.create_pending_request(
            period1, pa3,
            period1.start_date + timedelta(days=3),
            time(10, 0), time(16, 0),
            "New PA - available to help with coverage"
        )
        
        # Emily - Friday morning
        self.create_pending_request(
            period1, pa3,
            period1.start_date + timedelta(days=4),
            time(6, 0), time(14, 0),
            "Can cover morning shift on Friday"
        )
        
        # Week 2 - PENDING requests
        self.stdout.write('\nWeek 2 (Nov 9-15):')
        
        # Sarah - evening Monday
        self.create_pending_request(
            period2, pa1,
            period2.start_date,
            time(17, 0), time(22, 0),
            "Can work evening shift"
        )
        
        # Emily - morning Wednesday
        self.create_pending_request(
            period2, pa3,
            period2.start_date + timedelta(days=2),
            time(6, 0), time(12, 0),
            "Available for morning coverage"
        )
        
        # Michael - late night Saturday
        self.create_pending_request(
            period2, pa2,
            period2.start_date + timedelta(days=5),
            time(20, 0), time(23, 59),
            "Can cover late night if needed"
        )
        
        # Sarah - full day Sunday
        self.create_pending_request(
            period2, pa1,
            period2.start_date + timedelta(days=6),
            time(8, 0), time(18, 0),
            "Available for full day shift"
        )
        
        pending_count = ShiftRequest.objects.filter(status='PENDING').count()
        self.stdout.write(self.style.SUCCESS(f'\nâœ“ Total PENDING requests: {pending_count}'))
        self.stdout.write('\nðŸŽ‰ You can now test approve/reject on the calendar!')

    def create_pending_request(self, period, pa, date, start_time, end_time, notes):
        """Create a pending shift request"""
        # Check if already exists
        existing = ShiftRequest.objects.filter(
            schedule_period=period,
            requested_by=pa,
            date=date,
            start_time=start_time,
            status='PENDING'
        ).first()
        
        if existing:
            self.stdout.write(f'  âš  Already exists: {pa.first_name} on {date.strftime("%a %m/%d")}')
            return existing
        
        # Calculate duration
        start_datetime = datetime.combine(date, start_time)
        end_datetime = datetime.combine(date, end_time)
        if end_datetime < start_datetime:
            end_datetime += timedelta(days=1)
        duration = (end_datetime - start_datetime).total_seconds() / 3600
        
        shift = ShiftRequest.objects.create(
            schedule_period=period,
            requested_by=pa,
            date=date,
            start_time=start_time,
            end_time=end_time,
            duration_hours=Decimal(str(duration)),
            status='PENDING',
            notes=notes,
            created_at=timezone.now()
        )
        
        self.stdout.write(f'  âœ“ {pa.first_name} - {date.strftime("%a %m/%d")} {start_time.strftime("%I:%M%p")}-{end_time.strftime("%I:%M%p")}')
        return shift
```

# ==== apps/schedules/management/commands/create_test_data.py ====

```python
from django.core.management.base import BaseCommand
from django.utils import timezone
from datetime import datetime, time, timedelta
from apps.users.models import User, PAProfile
from apps.schedules.models import SchedulePeriod
from apps.shifts.models import ShiftRequest
from decimal import Decimal


class Command(BaseCommand):
    help = 'Create test data for PA scheduling system'

    def handle(self, *args, **kwargs):
        self.stdout.write('Creating test data...\n')
        
        # Get or create admin user
        admin = User.objects.filter(role='ADMIN').first()
        if not admin:
            self.stdout.write(self.style.ERROR('No admin user found. Please create an admin first.'))
            return
        
        # Create test PAs
        pa1 = self.create_test_pa(
            email='sarah.johnson@example.com',
            first_name='Sarah',
            last_name='Johnson',
            phone='+1-555-0101',
            max_hours=40
        )
        
        pa2 = self.create_test_pa(
            email='michael.chen@example.com',
            first_name='Michael',
            last_name='Chen',
            phone='+1-555-0102',
            max_hours=35
        )
        
        self.stdout.write(self.style.SUCCESS(f'âœ“ Created PA: {pa1.get_full_name()}'))
        self.stdout.write(self.style.SUCCESS(f'âœ“ Created PA: {pa2.get_full_name()}'))
        
        # Get existing period (Nov 2-8)
        period1 = SchedulePeriod.objects.filter(
            start_date=datetime(2025, 11, 2).date()
        ).first()
        
        if not period1:
            period1 = SchedulePeriod.objects.create(
                name='November 2-8, 2025',
                start_date=datetime(2025, 11, 2).date(),
                end_date=datetime(2025, 11, 8).date(),
                status='OPEN',
                created_by=admin
            )
            self.stdout.write(self.style.SUCCESS(f'âœ“ Created period: {period1.name}'))
        else:
            self.stdout.write(f'âœ“ Using existing period: {period1.name}')
        
        # Create new period (Nov 9-15)
        period2, created = SchedulePeriod.objects.get_or_create(
            start_date=datetime(2025, 11, 9).date(),
            defaults={
                'name': 'November 9-15, 2025',
                'end_date': datetime(2025, 11, 15).date(),
                'status': 'OPEN',
                'created_by': admin
            }
        )
        
        if created:
            self.stdout.write(self.style.SUCCESS(f'âœ“ Created period: {period2.name}'))
        else:
            self.stdout.write(f'âœ“ Period already exists: {period2.name}')
        
        # Create shifts for Period 1 (Nov 2-8)
        self.stdout.write('\nCreating shifts for Week 1 (Nov 2-8)...')
        self.create_week_shifts(period1, pa1, pa2, admin)
        
        # Create shifts for Period 2 (Nov 9-15)
        self.stdout.write('\nCreating shifts for Week 2 (Nov 9-15)...')
        self.create_week_shifts(period2, pa1, pa2, admin)
        
        self.stdout.write(self.style.SUCCESS('\nâœ“ Test data created successfully!'))
        self.stdout.write('\nSummary:')
        self.stdout.write(f'  - 2 Test PAs created')
        self.stdout.write(f'  - 2 Schedule periods')
        self.stdout.write(f'  - {ShiftRequest.objects.filter(status="APPROVED").count()} approved shifts')

    def create_test_pa(self, email, first_name, last_name, phone, max_hours):
        """Create or get a test PA user"""
        user, created = User.objects.get_or_create(
            email=email,
            defaults={
                'username': email.split('@')[0],
                'first_name': first_name,
                'last_name': last_name,
                'phone_number': phone,
                'role': 'PA',
                'is_email_verified': True,
                'is_active': True
            }
        )
        
        if created:
            user.set_password('testpass123')
            user.save()
        
        # Create or update PA profile
        profile, _ = PAProfile.objects.get_or_create(
            user=user,
            defaults={
                'max_hours_per_week': max_hours,
                'preferred_start_time': time(6, 0),
                'preferred_end_time': time(18, 0),
                'preferred_days': ['monday', 'wednesday', 'friday']
            }
        )
        
        return user

    def create_week_shifts(self, period, pa1, pa2, admin):
        """Create shifts for a week"""
        start_date = period.start_date
        
        # Pattern: Alternating coverage
        # Sarah: Morning shifts (6-9 AM) on Mon, Wed, Fri, Sun
        # Michael: Morning shifts on Tue, Thu, Sat
        # Both cover evenings (9-10 PM) on alternating days
        
        for day_offset in range(7):
            current_date = start_date + timedelta(days=day_offset)
            day_name = current_date.strftime('%A')
            
            # Morning shifts (6-9 AM) - Critical time coverage
            if day_name in ['Monday', 'Wednesday', 'Friday', 'Sunday']:
                self.create_shift(period, pa1, current_date, time(6, 0), time(14, 0), admin)
                self.stdout.write(f'  {current_date.strftime("%a %m/%d")}: Sarah 6am-2pm')
            else:
                self.create_shift(period, pa2, current_date, time(6, 0), time(14, 0), admin)
                self.stdout.write(f'  {current_date.strftime("%a %m/%d")}: Michael 6am-2pm')
            
            # Evening shifts (6-10 PM) - Covers evening critical time
            if day_name in ['Monday', 'Thursday', 'Saturday']:
                self.create_shift(period, pa2, current_date, time(18, 0), time(22, 0), admin)
                self.stdout.write(f'  {current_date.strftime("%a %m/%d")}: Michael 6pm-10pm')
            elif day_name in ['Tuesday', 'Friday', 'Sunday']:
                self.create_shift(period, pa1, current_date, time(18, 0), time(22, 0), admin)
                self.stdout.write(f'  {current_date.strftime("%a %m/%d")}: Sarah 6pm-10pm')
            
            # Wednesday: Full day for Michael (overlap example)
            if day_name == 'Wednesday':
                # Michael also gets evening shift
                self.create_shift(period, pa2, current_date, time(18, 0), time(22, 0), admin)
                self.stdout.write(f'  {current_date.strftime("%a %m/%d")}: Michael 6pm-10pm (double shift)')

    def create_shift(self, period, pa, date, start_time, end_time, admin):
        """Create an approved shift"""
        # Check if shift already exists
        existing = ShiftRequest.objects.filter(
            schedule_period=period,
            requested_by=pa,
            date=date,
            start_time=start_time,
            end_time=end_time
        ).first()
        
        if existing:
            return existing
        
        # Calculate duration
        start_datetime = datetime.combine(date, start_time)
        end_datetime = datetime.combine(date, end_time)
        if end_datetime < start_datetime:
            end_datetime += timedelta(days=1)
        duration = (end_datetime - start_datetime).total_seconds() / 3600
        
        shift = ShiftRequest.objects.create(
            schedule_period=period,
            requested_by=pa,
            date=date,
            start_time=start_time,
            end_time=end_time,
            duration_hours=Decimal(str(duration)),
            status='APPROVED',
            approved_by=admin,
            approved_at=timezone.now(),
            notes=f'Test shift for {pa.first_name}'
        )
        
        return shift
```

# ==== apps/schedules/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 18:20

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='SchedulePeriod',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('start_date', models.DateField()),
                ('end_date', models.DateField()),
                ('status', models.CharField(choices=[('OPEN', 'Open'), ('LOCKED', 'Locked'), ('FINALIZED', 'Finalized')], default='OPEN', max_length=10)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('created_by', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'schedule_periods',
                'ordering': ['-start_date'],
            },
        ),
    ]
```

# ==== apps/schedules/migrations/__init__.py ====

```python

```

# ==== apps/schedules/models.py ====

```python
# apps/schedules/models.py - NEEDS TO BE CREATED
from django.db import models
from django.conf import settings

class SchedulePeriod(models.Model):
    STATUS_CHOICES = [
        ('OPEN', 'Open'),
        ('LOCKED', 'Locked'),
        ('FINALIZED', 'Finalized'),
    ]
    
    name = models.CharField(max_length=100)
    start_date = models.DateField()
    end_date = models.DateField()
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='OPEN')
    created_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.PROTECT)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'schedule_periods'
        ordering = ['-start_date']
```

# ==== apps/schedules/routing.py ====

```python
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/schedule/(?P<period_id>\d+)/$', consumers.ScheduleConsumer.as_asgi()),
]
```

# ==== apps/schedules/serializers.py ====

```python
from rest_framework import serializers
from .models import SchedulePeriod
from apps.shifts.models import ShiftRequest
from apps.users.serializers import UserSerializer
from datetime import datetime, timedelta


class SchedulePeriodSerializer(serializers.ModelSerializer):
    """Basic serializer for listing schedule periods"""
    created_by_name = serializers.CharField(source='created_by.get_full_name', read_only=True)
    shift_count = serializers.SerializerMethodField()
    
    class Meta:
        model = SchedulePeriod
        fields = [
            'id', 'name', 'start_date', 'end_date', 'status',
            'created_by', 'created_by_name', 'shift_count',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'created_by', 'created_at', 'updated_at']
    
    def get_shift_count(self, obj):
        """Count total shifts in this period"""
        return obj.shiftrequest_set.count()
    
    def validate(self, data):
        """Validate that end_date is after start_date"""
        if data.get('end_date') and data.get('start_date'):
            if data['end_date'] < data['start_date']:
                raise serializers.ValidationError({
                    'end_date': 'End date must be after start date.'
                })
        return data


class SchedulePeriodDetailSerializer(SchedulePeriodSerializer):
    """Detailed serializer including all shifts"""
    shifts = serializers.SerializerMethodField()
    coverage_summary = serializers.SerializerMethodField()
    
    class Meta(SchedulePeriodSerializer.Meta):
        fields = SchedulePeriodSerializer.Meta.fields + ['shifts', 'coverage_summary']
    
    def get_shifts(self, obj):
        """Return all shifts"""
        from apps.shifts.serializers import ShiftRequestSerializer
        shifts = obj.shiftrequest_set.all().order_by('date', 'start_time')
        return ShiftRequestSerializer(shifts, many=True).data
    
    def get_coverage_summary(self, obj):
        """Summary of coverage for this period"""
        total_shifts = obj.shiftrequest_set.filter(status='APPROVED').count()
        pending_requests = obj.shiftrequest_set.filter(status='PENDING').count()
        
        return {
            'total_approved_shifts': total_shifts,
            'pending_requests': pending_requests,
            'status': obj.status
        }


class SchedulePeriodCreateUpdateSerializer(serializers.ModelSerializer):
    """Serializer for creating/updating periods"""
    class Meta:
        model = SchedulePeriod
        fields = ['name', 'start_date', 'end_date', 'status']
    
    def validate(self, data):
        """Validate dates"""
        if data.get('end_date') and data.get('start_date'):
            if data['end_date'] < data['start_date']:
                raise serializers.ValidationError({
                    'end_date': 'End date must be after start date.'
                })
        return data


class CalendarShiftSerializer(serializers.ModelSerializer):
    """Simplified shift serializer for calendar views"""
    requested_by_name = serializers.CharField(source='requested_by.get_full_name', read_only=True)
    requested_by = serializers.IntegerField(source='requested_by.id', read_only=True)
    
    class Meta:
        model = ShiftRequest
        fields = [
            'id', 'requested_by', 'requested_by_name', 'date', 
            'start_time', 'end_time', 'duration_hours',
            'notes', 'status'
        ]

class DayScheduleSerializer(serializers.Serializer):
    """Serializer for a single day's schedule"""
    date = serializers.DateField()
    day_name = serializers.CharField()
    shifts = CalendarShiftSerializer(many=True)
    coverage = serializers.DictField()
    total_hours = serializers.DecimalField(max_digits=5, decimal_places=2)


class WeekScheduleSerializer(serializers.Serializer):
    """Serializer for a week's schedule"""
    week_start = serializers.DateField()
    week_end = serializers.DateField()
    week_number = serializers.IntegerField()
    days = DayScheduleSerializer(many=True)


class MonthScheduleSerializer(serializers.Serializer):
    """Serializer for a month's schedule"""
    year = serializers.IntegerField()
    month = serializers.IntegerField()
    month_name = serializers.CharField()
    weeks = WeekScheduleSerializer(many=True)
    total_shifts = serializers.IntegerField()
    coverage_stats = serializers.DictField()
```

# ==== apps/schedules/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/schedules/urls.py ====

```python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import SchedulePeriodViewSet, MonthViewAPI, WeekViewAPI, DayViewAPI

router = DefaultRouter()
router.register(r'', SchedulePeriodViewSet, basename='schedule-period')

urlpatterns = [
    path('', include(router.urls)),
    # Calendar views
    path('calendar/month/<int:year>/<int:month>/', MonthViewAPI.as_view(), name='calendar-month'),
    path('calendar/week/<int:year>/<int:week>/', WeekViewAPI.as_view(), name='calendar-week'),
    path('calendar/day/<str:date>/', DayViewAPI.as_view(), name='calendar-day'),
]
```

# ==== apps/schedules/utils.py ====

```python
from datetime import datetime, timedelta, time
from calendar import monthrange
from apps.shifts.models import ShiftRequest
from apps.coverage.models import CriticalTimeCoverage


def check_shift_conflicts(schedule_period, date, start_time, end_time, exclude_request_id=None):
    """
    Check if requested time conflicts with any APPROVED shift.
    Only APPROVED shifts block new requests (PENDING doesn't block).
    
    Args:
        schedule_period: SchedulePeriod instance
        date: datetime.date
        start_time: datetime.time
        end_time: datetime.time
        exclude_request_id: Optional request ID to exclude from conflict check
    
    Returns:
        bool: True if there are conflicts, False otherwise
    """
    conflicts = ShiftRequest.objects.filter(
        date=date,
        status='APPROVED'
    )
    
    if exclude_request_id:
        conflicts = conflicts.exclude(id=exclude_request_id)
    
    requested_start = datetime.combine(date, start_time)
    requested_end = datetime.combine(date, end_time)
    
    if requested_end <= requested_start:
        requested_end += timedelta(days=1)
    
    for shift in conflicts:
        shift_start = datetime.combine(shift.date, shift.start_time)
        shift_end = datetime.combine(shift.date, shift.end_time)
        
        if shift_end <= shift_start:
            shift_end += timedelta(days=1)
        
        if requested_start < shift_end and requested_end > shift_start:
            return True
    
    return False


def get_coverage_for_date(date):
    """
    Get coverage status for a specific date.
    Returns dict with morning_covered, evening_covered, and coverage_status.
    """
    try:
        coverage = CriticalTimeCoverage.objects.get(date=date)
        return {
            'morning_covered': coverage.morning_covered,
            'evening_covered': coverage.evening_covered,
            'coverage_status': coverage.coverage_status,
        }
    except CriticalTimeCoverage.DoesNotExist:
        shifts = ShiftRequest.objects.filter(
            date=date,
            status='APPROVED'
        )
        
        morning_covered = False
        evening_covered = False
        
        for shift in shifts:
            is_overnight = shift.end_time < shift.start_time
            
            if is_overnight:
                if shift.start_time <= time(21, 0):
                    evening_covered = True
                if shift.end_time >= time(9, 0):
                    morning_covered = True
            else:
                if shift.start_time <= time(6, 0) and shift.end_time >= time(9, 0):
                    morning_covered = True
                if shift.start_time <= time(21, 0) and shift.end_time >= time(22, 0):
                    evening_covered = True
        
        if morning_covered and evening_covered:
            status = 'complete'
        elif morning_covered or evening_covered:
            status = 'partial'
        else:
            status = 'none'
        
        return {
            'morning_covered': morning_covered,
            'evening_covered': evening_covered,
            'coverage_status': status,
        }


def get_shifts_for_date(date):
    """Get all approved shifts for a specific date"""
    return ShiftRequest.objects.filter(
        date=date,
        status='APPROVED'
    ).select_related('requested_by').order_by('start_time')


def get_month_data(year, month):
    """
    Get calendar data for an entire month.
    Returns dict with all days and their shifts/coverage.
    """
    _, last_day = monthrange(year, month)
    start_date = datetime(year, month, 1).date()
    end_date = datetime(year, month, last_day).date()
    
    shifts = ShiftRequest.objects.filter(
        date__gte=start_date,
        date__lte=end_date,
        status='APPROVED'
    ).select_related('requested_by').order_by('date', 'start_time')
    
    shifts_by_date = {}
    for shift in shifts:
        if shift.date not in shifts_by_date:
            shifts_by_date[shift.date] = []
        shifts_by_date[shift.date].append(shift)
    
    days = []
    current_date = start_date
    
    while current_date <= end_date:
        coverage = get_coverage_for_date(current_date)
        day_shifts = shifts_by_date.get(current_date, [])
        
        days.append({
            'date': current_date,
            'morning_covered': coverage['morning_covered'],
            'evening_covered': coverage['evening_covered'],
            'coverage_status': coverage['coverage_status'],
            'shifts': day_shifts,
        })
        
        current_date += timedelta(days=1)
    
    total_days = len(days)
    complete_days = sum(1 for d in days if d['coverage_status'] == 'complete')
    partial_days = sum(1 for d in days if d['coverage_status'] == 'partial')
    no_coverage_days = sum(1 for d in days if d['coverage_status'] == 'none')
    
    return {
        'year': year,
        'month': month,
        'month_name': start_date.strftime('%B %Y'),
        'days': days,
        'total_shifts': len(shifts),
        'coverage_summary': {
            'total_days': total_days,
            'complete_coverage': complete_days,
            'partial_coverage': partial_days,
            'no_coverage': no_coverage_days,
        }
    }


def get_week_data(year, week_number):
    """
    Get calendar data for a specific week.
    Week starts on Monday (ISO week).
    """
    jan_4 = datetime(year, 1, 4)
    week_start = jan_4 - timedelta(days=jan_4.weekday()) + timedelta(weeks=week_number - 1)
    week_start = week_start.date()
    week_end = week_start + timedelta(days=6)
    
    shifts = ShiftRequest.objects.filter(
        date__gte=week_start,
        date__lte=week_end,
        status='APPROVED'
    ).select_related('requested_by').order_by('date', 'start_time')
    
    shifts_by_date = {}
    for shift in shifts:
        if shift.date not in shifts_by_date:
            shifts_by_date[shift.date] = []
        shifts_by_date[shift.date].append(shift)
    
    days = []
    current_date = week_start
    
    for _ in range(7):
        coverage = get_coverage_for_date(current_date)
        day_shifts = shifts_by_date.get(current_date, [])
        
        days.append({
            'date': current_date,
            'morning_covered': coverage['morning_covered'],
            'evening_covered': coverage['evening_covered'],
            'coverage_status': coverage['coverage_status'],
            'shifts': day_shifts,
        })
        
        current_date += timedelta(days=1)
    
    return {
        'year': year,
        'week_number': week_number,
        'week_start': week_start,
        'week_end': week_end,
        'days': days,
        'total_shifts': len(shifts),
    }


def get_day_data(date):
    """
    Get detailed data for a single day including hourly timeline.
    """
    coverage = get_coverage_for_date(date)
    shifts = get_shifts_for_date(date)
    
    hourly_timeline = {}
    for hour in range(6, 23):
        hour_start = time(hour, 0)
        hour_end = time(hour + 1, 0) if hour < 23 else time(23, 59)
        
        covering_shifts = []
        for shift in shifts:
            if shift.start_time <= hour_start and shift.end_time >= hour_end:
                covering_shifts.append({
                    'id': shift.id,
                    'pa_name': shift.requested_by.get_full_name(),
                    'pa_id': shift.requested_by.id,
                })
        
        hourly_timeline[f"{hour:02d}:00"] = covering_shifts
    
    return {
        'date': date,
        'day_name': date.strftime('%A, %B %d, %Y'),
        'morning_covered': coverage['morning_covered'],
        'evening_covered': coverage['evening_covered'],
        'coverage_status': coverage['coverage_status'],
        'shifts': shifts,
        'hourly_timeline': hourly_timeline,
    }
```

# ==== apps/schedules/views.py ====

```python
from rest_framework import viewsets, status, permissions
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.views import APIView
from django.shortcuts import get_object_or_404
from django.db.models import Sum, Q
from datetime import datetime, timedelta
from calendar import monthrange
from .models import SchedulePeriod
from apps.shifts.models import ShiftRequest
from apps.coverage.models import CriticalTimeCoverage
from .serializers import (
    SchedulePeriodSerializer,
    SchedulePeriodDetailSerializer,
    SchedulePeriodCreateUpdateSerializer,
    CalendarShiftSerializer,
    DayScheduleSerializer,
    WeekScheduleSerializer,
    MonthScheduleSerializer
)


class IsAdminUser(permissions.BasePermission):
    """Custom permission: only admin users"""
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and request.user.role == 'ADMIN'


class SchedulePeriodViewSet(viewsets.ModelViewSet):
    """
    ViewSet for Schedule Periods
    
    List: GET /api/schedule-periods/ (all users)
    Retrieve: GET /api/schedule-periods/{id}/ (all users)
    Create: POST /api/schedule-periods/ (admin only)
    Update: PUT/PATCH /api/schedule-periods/{id}/ (admin only)
    Delete: DELETE /api/schedule-periods/{id}/ (admin only)
    Finalize: POST /api/schedule-periods/{id}/finalize/ (admin only)
    """
    queryset = SchedulePeriod.objects.all().order_by('-start_date')
    
    def get_serializer_class(self):
        """Use different serializers for different actions"""
        if self.action == 'retrieve':
            return SchedulePeriodDetailSerializer
        elif self.action in ['create', 'update', 'partial_update']:
            return SchedulePeriodCreateUpdateSerializer
        return SchedulePeriodSerializer
    
    def get_permissions(self):
        """Admin only for create/update/delete"""
        if self.action in ['create', 'update', 'partial_update', 'destroy', 'finalize']:
            return [IsAdminUser()]
        return [permissions.IsAuthenticated()]
    
    def perform_create(self, serializer):
        """Set created_by to current user"""
        serializer.save(created_by=self.request.user)
        
    @action(detail=True, methods=['post'])
    def finalize(self, request, pk=None):
        """
        Finalize a schedule period (admin only)
        Shows coverage warnings but does NOT block finalization.
        """
        period = self.get_object()
        
        if period.status == 'FINALIZED':
            return Response(
                {'error': 'This period is already finalized.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        from apps.coverage.models import CriticalTimeCoverage
        from datetime import timedelta
        
        coverage_warnings = []
        current_date = period.start_date
        
        while current_date <= period.end_date:
            try:
                coverage = CriticalTimeCoverage.objects.get(date=current_date)
                if not coverage.morning_covered:
                    coverage_warnings.append(f"{current_date.strftime('%b %d')}: Morning (6-9 AM) not covered")
                if not coverage.evening_covered:
                    coverage_warnings.append(f"{current_date.strftime('%b %d')}: Evening (9-10 PM) not covered")
            except CriticalTimeCoverage.DoesNotExist:
                coverage_warnings.append(f"{current_date.strftime('%b %d')}: No coverage at all")
            
            current_date += timedelta(days=1)
        
        period.status = 'FINALIZED'
        period.save()
        
        from apps.shifts.models import ShiftRequest
        pending = ShiftRequest.objects.filter(
            schedule_period=period,
            status='PENDING'
        )
        rejected_count = pending.count()
        pending.update(
            status='REJECTED',
            rejected_reason='Schedule period has been finalized'
        )
        
        from apps.users.models import User
        pa_emails = list(User.objects.filter(role='PA', is_active=True).values_list('email', flat=True))
        
        from apps.schedules.websocket_utils import broadcast_period_finalized
        broadcast_period_finalized(period, message=f'{period.name} has been finalized')
        
        response_data = {
            'message': f'Schedule period "{period.name}" finalized successfully.',
            'period': SchedulePeriodSerializer(period).data,
            'rejected_requests': rejected_count,
        }
        
        if coverage_warnings:
            response_data['coverage_warnings'] = coverage_warnings
            response_data['warning_count'] = len(coverage_warnings)
        else:
            response_data['coverage_status'] = 'All critical times covered! âœ…'
        
        return Response(response_data, status=status.HTTP_200_OK)


class MonthViewAPI(APIView):
    """
    GET /api/calendar/month/{year}/{month}/
    Returns approved AND pending shifts for a given month in calendar format
    
    Query params:
    - pa_id: Filter by specific PA
    - status: Filter by status (APPROVED, PENDING, etc.) - defaults to both APPROVED and PENDING
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, year, month):
        """Get month view data with both approved and pending shifts"""
        try:
            year = int(year)
            month = int(month)
            
            if not (1 <= month <= 12):
                return Response(
                    {'error': 'Month must be between 1 and 12'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            first_day = datetime(year, month, 1).date()
            last_day = datetime(year, month, monthrange(year, month)[1]).date()
            
            status_filter = request.query_params.get('status')
            
            if status_filter:
                shifts = ShiftRequest.objects.filter(
                    date__gte=first_day,
                    date__lte=last_day,
                    status=status_filter.upper()
                )
            else:
                shifts = ShiftRequest.objects.filter(
                    date__gte=first_day,
                    date__lte=last_day,
                    status__in=['APPROVED', 'PENDING']
                )
            
            shifts = shifts.select_related('requested_by', 'schedule_period').order_by('date', 'start_time')
            
            # FIXED: Convert pa_id to integer
            pa_id = request.query_params.get('pa_id')
            if pa_id:
                try:
                    pa_id = int(pa_id)
                    shifts = shifts.filter(requested_by_id=pa_id)
                except (ValueError, TypeError):
                    return Response(
                        {'error': 'Invalid pa_id parameter'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
            
            weeks = []
            current_date = first_day
            
            while current_date.weekday() != 0:
                current_date -= timedelta(days=1)
            
            week_number = 1
            while current_date <= last_day or current_date.month == month:
                week_start = current_date
                week_end = current_date + timedelta(days=6)
                
                days = []
                for day_offset in range(7):
                    day_date = week_start + timedelta(days=day_offset)
                    
                    day_shifts = [s for s in shifts if s.date == day_date]
                    
                    coverage = self._get_day_coverage(day_date)
                    
                    total_hours = sum(s.duration_hours for s in day_shifts)
                    
                    days.append({
                        'date': day_date,
                        'day_name': day_date.strftime('%A'),
                        'shifts': CalendarShiftSerializer(day_shifts, many=True).data,
                        'coverage': coverage,
                        'total_hours': total_hours,
                        'is_current_month': day_date.month == month
                    })
                
                weeks.append({
                    'week_start': week_start,
                    'week_end': week_end,
                    'week_number': week_number,
                    'days': days
                })
                
                current_date = week_end + timedelta(days=1)
                week_number += 1
                
                if week_number > 6:
                    break
            
            coverage_stats = self._get_month_coverage_stats(first_day, last_day)
            
            response_data = {
                'year': year,
                'month': month,
                'month_name': first_day.strftime('%B %Y'),
                'weeks': weeks,
                'total_shifts': shifts.count(),
                'coverage_stats': coverage_stats
            }
            
            return Response(response_data)
            
        except ValueError:
            return Response(
                {'error': 'Invalid year or month'},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    def _get_day_coverage(self, date):
        """Get coverage status for a specific day"""
        try:
            coverage = CriticalTimeCoverage.objects.get(date=date)
            return {
                'morning_covered': coverage.morning_covered,
                'evening_covered': coverage.evening_covered,
                'status': coverage.coverage_status
            }
        except CriticalTimeCoverage.DoesNotExist:
            return {
                'morning_covered': False,
                'evening_covered': False,
                'status': 'none'
            }
    
    def _get_month_coverage_stats(self, start_date, end_date):
        """Calculate coverage statistics for the month"""
        total_days = (end_date - start_date).days + 1
        
        coverage_records = CriticalTimeCoverage.objects.filter(
            date__gte=start_date,
            date__lte=end_date
        )
        
        fully_covered = coverage_records.filter(
            morning_covered=True,
            evening_covered=True
        ).count()
        
        partially_covered = coverage_records.filter(
            Q(morning_covered=True, evening_covered=False) |
            Q(morning_covered=False, evening_covered=True)
        ).count()
        
        not_covered = total_days - fully_covered - partially_covered
        
        return {
            'total_days': total_days,
            'fully_covered': fully_covered,
            'partially_covered': partially_covered,
            'not_covered': not_covered,
            'coverage_percentage': round((fully_covered / total_days * 100), 1) if total_days > 0 else 0
        }

class WeekViewAPI(APIView):
    """
    GET /api/calendar/week/{year}/{week}/
    Returns approved AND pending shifts for a given week (ISO week number)
    
    Query params:
    - pa_id: Filter by specific PA
    - status: Filter by status (APPROVED, PENDING, etc.) - defaults to both APPROVED and PENDING
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, year, week):
        """Get week view data with both approved and pending shifts"""
        try:
            year = int(year)
            week = int(week)
            
            if not (1 <= week <= 53):
                return Response(
                    {'error': 'Week must be between 1 and 53'},
                    status=status.HTTP_400_BAD_REQUEST
                )
            
            jan_4 = datetime(year, 1, 4).date()
            week_1_monday = jan_4 - timedelta(days=jan_4.weekday())
            week_start = week_1_monday + timedelta(weeks=week - 1)
            week_end = week_start + timedelta(days=6)
            
            status_filter = request.query_params.get('status')
            
            if status_filter:
                shifts = ShiftRequest.objects.filter(
                    date__gte=week_start,
                    date__lte=week_end,
                    status=status_filter.upper()
                )
            else:
                shifts = ShiftRequest.objects.filter(
                    date__gte=week_start,
                    date__lte=week_end,
                    status__in=['APPROVED', 'PENDING']
                )
            
            shifts = shifts.select_related('requested_by', 'schedule_period').order_by('date', 'start_time')
            
            pa_id = request.query_params.get('pa_id')
            if pa_id:
                try:
                    pa_id = int(pa_id)
                    shifts = shifts.filter(requested_by_id=pa_id)
                except (ValueError, TypeError):
                    return Response(
                        {'error': 'Invalid pa_id parameter'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
            
            days = []
            for day_offset in range(7):
                day_date = week_start + timedelta(days=day_offset)
                
                day_shifts = [s for s in shifts if s.date == day_date]
                
                coverage = self._get_day_coverage(day_date)
                
                total_hours = sum(s.duration_hours for s in day_shifts)
                
                days.append({
                    'date': day_date.isoformat(),
                    'day_name': day_date.strftime('%A'),
                    'shifts': CalendarShiftSerializer(day_shifts, many=True).data,
                    'coverage': coverage,
                    'total_hours': float(total_hours)
                })
            
            response_data = {
                'week_start': week_start.isoformat(),
                'week_end': week_end.isoformat(),
                'week_number': week,
                'year': year,
                'days': days,
                'total_shifts': shifts.count()
            }
            
            return Response(response_data)
            
        except ValueError:
            return Response(
                {'error': 'Invalid year or week'},
                status=status.HTTP_400_BAD_REQUEST
            )
    
    def _get_day_coverage(self, date):
        """Get coverage status for a specific day"""
        try:
            coverage = CriticalTimeCoverage.objects.get(date=date)
            return {
                'morning_covered': coverage.morning_covered,
                'evening_covered': coverage.evening_covered,
                'status': coverage.coverage_status
            }
        except CriticalTimeCoverage.DoesNotExist:
            return {
                'morning_covered': False,
                'evening_covered': False,
                'status': 'none'
            }


class DayViewAPI(APIView):
    """
    GET /api/calendar/day/{date}/
    Returns approved AND pending shifts for a specific day with hourly breakdown
    Date format: YYYY-MM-DD
    
    Query params:
    - pa_id: Filter by specific PA
    - status: Filter by status (APPROVED, PENDING, etc.) - defaults to both APPROVED and PENDING
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def get(self, request, date):
        """Get day view data with both approved and pending shifts"""
        try:
            day_date = datetime.strptime(date, '%Y-%m-%d').date()
            
            status_filter = request.query_params.get('status')
            
            if status_filter:
                shifts = ShiftRequest.objects.filter(
                    date=day_date,
                    status=status_filter.upper()
                )
            else:
                shifts = ShiftRequest.objects.filter(
                    date=day_date,
                    status__in=['APPROVED', 'PENDING']
                )
            
            shifts = shifts.select_related('requested_by', 'schedule_period').order_by('start_time')
            
            # FIXED: Convert pa_id to integer
            pa_id = request.query_params.get('pa_id')
            if pa_id:
                try:
                    pa_id = int(pa_id)
                    shifts = shifts.filter(requested_by_id=pa_id)
                except (ValueError, TypeError):
                    return Response(
                        {'error': 'Invalid pa_id parameter'},
                        status=status.HTTP_400_BAD_REQUEST
                    )
            
            try:
                coverage = CriticalTimeCoverage.objects.get(date=day_date)
                coverage_data = {
                    'morning_covered': coverage.morning_covered,
                    'evening_covered': coverage.evening_covered,
                    'morning_shift': CalendarShiftSerializer(coverage.morning_shift).data if coverage.morning_shift else None,
                    'evening_shift': CalendarShiftSerializer(coverage.evening_shift).data if coverage.evening_shift else None,
                    'status': coverage.coverage_status
                }
            except CriticalTimeCoverage.DoesNotExist:
                coverage_data = {
                    'morning_covered': False,
                    'evening_covered': False,
                    'morning_shift': None,
                    'evening_shift': None,
                    'status': 'none'
                }
            
            total_hours = sum(s.duration_hours for s in shifts)
            
            timeline = []
            for hour in range(24):
                hour_shifts = [
                    s for s in shifts 
                    if s.start_time.hour <= hour < s.end_time.hour or
                    (s.start_time.hour > s.end_time.hour and (hour >= s.start_time.hour or hour < s.end_time.hour))
                ]
                
                timeline.append({
                    'hour': hour,
                    'hour_label': f'{hour:02d}:00',
                    'shifts': CalendarShiftSerializer(hour_shifts, many=True).data,
                    'is_critical_time': (6 <= hour < 9) or (21 <= hour < 22)
                })
            
            response_data = {
                'date': day_date,
                'day_name': day_date.strftime('%A, %B %d, %Y'),
                'shifts': CalendarShiftSerializer(shifts, many=True).data,
                'coverage': coverage_data,
                'total_hours': total_hours,
                'timeline': timeline
            }
            
            return Response(response_data)
            
        except ValueError:
            return Response(
                {'error': 'Invalid date format. Use YYYY-MM-DD'},
                status=status.HTTP_400_BAD_REQUEST
            )
```

# ==== apps/schedules/websocket_utils.py ====

```python
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from apps.shifts.serializers import ShiftRequestSerializer
import logging

logger = logging.getLogger(__name__)


def broadcast_shift_event(event_type, shift, message=None, changes=None):
    """
    Broadcast shift events to WebSocket clients.
    
    Args:
        event_type: Type of event (requested, approved, rejected, updated, deleted)
        shift: ShiftRequest instance (or None for deleted)
        message: Optional custom message
        changes: Optional dict of changes (for updated events)
    """
    channel_layer = get_channel_layer()
    
    if shift and hasattr(shift, 'schedule_period'):
        period_id = shift.schedule_period.id
        room_group_name = f'schedule_{period_id}'
        
        # Prepare shift data
        if event_type != 'deleted':
            shift_data = ShiftRequestSerializer(shift).data
        else:
            shift_data = None
        
        # Prepare event data
        event_data = {
            'type': f'shift_{event_type}',  # Converts to shift_requested, shift_approved, etc.
            'message': message or f'Shift {event_type}'
        }
        
        if shift_data:
            event_data['shift'] = shift_data
        
        if event_type == 'deleted':
            event_data['shift_id'] = shift.id if shift else None
        
        if changes:
            event_data['changes'] = changes
        
        # Broadcast to group
        try:
            async_to_sync(channel_layer.group_send)(
                room_group_name,
                event_data
            )
            logger.info(f'WebSocket broadcast: {event_type} for shift {shift.id if shift else "N/A"} in period {period_id}')
        except Exception as e:
            logger.error(f'Failed to broadcast WebSocket event: {e}')


def broadcast_coverage_alert(date, coverage, period_id, message=None):
    """
    Broadcast coverage alert to WebSocket clients.
    
    Args:
        date: Date of coverage change
        coverage: Coverage data dict
        period_id: Schedule period ID
        message: Optional custom message
    """
    channel_layer = get_channel_layer()
    room_group_name = f'schedule_{period_id}'
    
    event_data = {
        'type': 'coverage_alert',
        'date': str(date),
        'coverage': coverage,
        'message': message or 'Coverage status updated'
    }
    
    try:
        async_to_sync(channel_layer.group_send)(
            room_group_name,
            event_data
        )
        logger.info(f'WebSocket broadcast: coverage alert for {date} in period {period_id}')
    except Exception as e:
        logger.error(f'Failed to broadcast coverage alert: {e}')


def broadcast_period_finalized(period, message=None):
    """
    Broadcast period finalization to WebSocket clients.
    
    Args:
        period: SchedulePeriod instance
        message: Optional custom message
    """
    channel_layer = get_channel_layer()
    room_group_name = f'schedule_{period.id}'
    
    from apps.schedules.serializers import SchedulePeriodSerializer
    
    event_data = {
        'type': 'period_finalized',
        'period': SchedulePeriodSerializer(period).data,
        'message': message or f'{period.name} has been finalized'
    }
    
    try:
        async_to_sync(channel_layer.group_send)(
            room_group_name,
            event_data
        )
        logger.info(f'WebSocket broadcast: period {period.id} finalized')
    except Exception as e:
        logger.error(f'Failed to broadcast period finalized: {e}')
```

# ==== apps/shifts/__init__.py ====

```python

```

# ==== apps/shifts/admin.py ====

```python
from django.contrib import admin
from .models import ShiftRequest


@admin.register(ShiftRequest)
class ShiftRequestAdmin(admin.ModelAdmin):
    list_display = [
        'id', 'date', 'start_time', 'end_time', 'requested_by',
        'status', 'duration_hours', 'schedule_period', 'created_at'
    ]
    list_filter = ['status', 'date', 'schedule_period']
    search_fields = ['requested_by__email', 'requested_by__first_name', 'requested_by__last_name']
    readonly_fields = ['duration_hours', 'created_at', 'updated_at', 'approved_at']
    
    fieldsets = (
        ('Shift Details', {
            'fields': ('schedule_period', 'requested_by', 'date', 'start_time', 'end_time', 'duration_hours')
        }),
        ('Status', {
            'fields': ('status', 'approved_by', 'approved_at')
        }),
        ('Notes', {
            'fields': ('notes', 'admin_notes', 'rejected_reason')
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at'),
            'classes': ('collapse',)
        }),
    )
    
    def get_queryset(self, request):
        return super().get_queryset(request).select_related(
            'schedule_period', 'requested_by', 'approved_by'
        )
```

# ==== apps/shifts/apps.py ====

```python
from django.apps import AppConfig


class ShiftsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.shifts'
```

# ==== apps/shifts/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 18:20

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('schedules', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ShiftRequest',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField()),
                ('start_time', models.TimeField()),
                ('end_time', models.TimeField()),
                ('duration_hours', models.DecimalField(decimal_places=2, max_digits=4)),
                ('status', models.CharField(choices=[('PENDING', 'Pending'), ('APPROVED', 'Approved'), ('REJECTED', 'Rejected'), ('CANCELLED', 'Cancelled')], default='PENDING', max_length=10)),
                ('notes', models.TextField(blank=True)),
                ('admin_notes', models.TextField(blank=True)),
                ('rejected_reason', models.TextField(blank=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('approved_at', models.DateTimeField(blank=True, null=True)),
                ('approved_by', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='approved_shifts', to=settings.AUTH_USER_MODEL)),
                ('requested_by', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                ('schedule_period', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='schedules.scheduleperiod')),
            ],
            options={
                'db_table': 'shift_requests',
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/shifts/migrations/0002_shiftsuggestion.py ====

```python
# Generated by Django 5.2.7 on 2025-11-02 23:37

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('schedules', '0001_initial'),
        ('shifts', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ShiftSuggestion',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('date', models.DateField()),
                ('start_time', models.TimeField()),
                ('end_time', models.TimeField()),
                ('duration_hours', models.DecimalField(decimal_places=2, max_digits=4)),
                ('message', models.TextField(blank=True)),
                ('decline_reason', models.TextField(blank=True)),
                ('status', models.CharField(choices=[('PENDING', 'Pending'), ('ACCEPTED', 'Accepted'), ('DECLINED', 'Declined'), ('EXPIRED', 'Expired')], default='PENDING', max_length=10)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('responded_at', models.DateTimeField(blank=True, null=True)),
                ('related_shift_request', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='source_suggestion', to='shifts.shiftrequest')),
                ('schedule_period', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='schedules.scheduleperiod')),
                ('suggested_by', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='suggestions_made', to=settings.AUTH_USER_MODEL)),
                ('suggested_to', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='suggestions_received', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'shift_suggestions',
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/shifts/migrations/0003_shiftrequest_cancellation_reason.py ====

```python
# Generated by Django 5.2.7 on 2025-11-05 19:20

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('shifts', '0002_shiftsuggestion'),
    ]

    operations = [
        migrations.AddField(
            model_name='shiftrequest',
            name='cancellation_reason',
            field=models.TextField(blank=True, default=''),
        ),
    ]
```

# ==== apps/shifts/migrations/__init__.py ====

```python

```

# ==== apps/shifts/models.py ====

```python
from django.db import models
from django.conf import settings
from decimal import Decimal
from datetime import datetime, timedelta


class ShiftRequest(models.Model):
    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('APPROVED', 'Approved'),
        ('REJECTED', 'Rejected'),
        ('CANCELLED', 'Cancelled'),
    ]
    
    schedule_period = models.ForeignKey('schedules.SchedulePeriod', on_delete=models.CASCADE)
    requested_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    date = models.DateField()
    start_time = models.TimeField()
    end_time = models.TimeField()
    duration_hours = models.DecimalField(max_digits=4, decimal_places=2)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='PENDING')
    notes = models.TextField(blank=True)
    admin_notes = models.TextField(blank=True)
    rejected_reason = models.TextField(blank=True)
    cancellation_reason = models.TextField(blank=True, default='')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    approved_at = models.DateTimeField(null=True, blank=True)
    approved_by = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        related_name='approved_shifts'
    )
    
    class Meta:
        db_table = 'shift_requests'
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        if self.start_time and self.end_time:
            from datetime import datetime, timedelta
            start = datetime.combine(datetime.today(), self.start_time)
            end = datetime.combine(datetime.today(), self.end_time)
            if end < start:
                end += timedelta(days=1)
            duration = (end - start).total_seconds() / 3600
            self.duration_hours = Decimal(str(duration))
        super().save(*args, **kwargs)


class ShiftSuggestion(models.Model):
    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('ACCEPTED', 'Accepted'),
        ('DECLINED', 'Declined'),
        ('EXPIRED', 'Expired'),
    ]
    
    suggested_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='suggestions_made'
    )
    suggested_to = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='suggestions_received'
    )
    schedule_period = models.ForeignKey('schedules.SchedulePeriod', on_delete=models.CASCADE)
    date = models.DateField()
    start_time = models.TimeField()
    end_time = models.TimeField()
    duration_hours = models.DecimalField(max_digits=4, decimal_places=2)
    message = models.TextField(blank=True)
    decline_reason = models.TextField(blank=True)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='PENDING')
    related_shift_request = models.ForeignKey(
        ShiftRequest,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='source_suggestion'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    responded_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        db_table = 'shift_suggestions'
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        if self.start_time and self.end_time:
            from datetime import datetime, timedelta
            start = datetime.combine(datetime.today(), self.start_time)
            end = datetime.combine(datetime.today(), self.end_time)
            if end < start:
                end += timedelta(days=1)
            duration = (end - start).total_seconds() / 3600
            self.duration_hours = Decimal(str(duration))
        super().save(*args, **kwargs)
    
    def __str__(self):
        return f"Suggestion from {self.suggested_by} to {self.suggested_to} for {self.date}"
```

# ==== apps/shifts/serializers.py ====

```python
from rest_framework import serializers
from django.utils import timezone
from datetime import datetime, timedelta
from .models import ShiftRequest, ShiftSuggestion
from apps.schedules.models import SchedulePeriod
from apps.users.serializers import UserSerializer


class ShiftRequestSerializer(serializers.ModelSerializer):
    requested_by_name = serializers.CharField(source='requested_by.get_full_name', read_only=True)
    approved_by_name = serializers.CharField(source='approved_by.get_full_name', read_only=True)
    schedule_period_name = serializers.CharField(source='schedule_period.name', read_only=True)
    
    class Meta:
        model = ShiftRequest
        fields = [
            'id', 'schedule_period', 'schedule_period_name',
            'requested_by', 'requested_by_name',
            'date', 'start_time', 'end_time', 'duration_hours',
            'status', 'notes', 'admin_notes', 'rejected_reason',
            'created_at', 'updated_at', 'approved_at', 
            'approved_by', 'approved_by_name'
        ]
        read_only_fields = [
            'id', 'duration_hours', 'status', 'approved_at', 
            'approved_by', 'created_at', 'updated_at', 'requested_by'
        ]


class ShiftRequestCreateSerializer(serializers.ModelSerializer):
    
    class Meta:
        model = ShiftRequest
        fields = ['schedule_period', 'date', 'start_time', 'end_time', 'notes']
    
    def validate_schedule_period(self, value):
        if value.status != 'OPEN':
            raise serializers.ValidationError(
                f'Cannot submit requests for {value.status} periods. Period must be OPEN.'
            )
        return value
    
    def validate(self, data):
        schedule_period = data.get('schedule_period')
        date = data.get('date')
        start_time = data.get('start_time')
        end_time = data.get('end_time')
        
        request = self.context.get('request')
        if not request or not request.user:
            raise serializers.ValidationError('User context required')
        
        requested_by = request.user
        
        if schedule_period and date:
            if not (schedule_period.start_date <= date <= schedule_period.end_date):
                raise serializers.ValidationError(
                    f'Date must be within period range: {schedule_period.start_date} to {schedule_period.end_date}'
                )
        
        if date and date < timezone.now().date():
            raise serializers.ValidationError('Cannot request shifts for past dates')
        
        if schedule_period and date and start_time and end_time:
            from apps.schedules.utils import check_shift_conflicts
            conflicts = check_shift_conflicts(
                schedule_period=schedule_period,
                date=date,
                start_time=start_time,
                end_time=end_time,
                exclude_request_id=None
            )
            if conflicts:
                raise serializers.ValidationError(
                    'This shift conflicts with existing approved shifts'
                )
        
        return data


class ShiftSuggestionSerializer(serializers.ModelSerializer):
    suggested_by_name = serializers.CharField(source='suggested_by.get_full_name', read_only=True)
    suggested_to_name = serializers.CharField(source='suggested_to.get_full_name', read_only=True)
    schedule_period_name = serializers.CharField(source='schedule_period.name', read_only=True)
    
    class Meta:
        model = ShiftSuggestion
        fields = [
            'id', 'suggested_by', 'suggested_by_name',
            'suggested_to', 'suggested_to_name',
            'schedule_period', 'schedule_period_name',
            'date', 'start_time', 'end_time', 'duration_hours',
            'message', 'decline_reason', 'status',
            'related_shift_request', 'created_at', 'responded_at'
        ]
        read_only_fields = [
            'id', 'suggested_by', 'duration_hours', 'status',
            'related_shift_request', 'created_at', 'responded_at'
        ]


class ShiftSuggestionCreateSerializer(serializers.ModelSerializer):
    
    class Meta:
        model = ShiftSuggestion
        fields = ['suggested_to', 'schedule_period', 'date', 'start_time', 'end_time', 'message']
    
    def validate_schedule_period(self, value):
        if value.status not in ['OPEN', 'LOCKED']:
            raise serializers.ValidationError('Period must be OPEN or LOCKED')
        return value
    
    def validate_suggested_to(self, value):
        if value.role != 'PA':
            raise serializers.ValidationError('Can only suggest shifts to PAs')
        return value
    
    def validate(self, data):
        date = data.get('date')
        schedule_period = data.get('schedule_period')
        
        if schedule_period and date:
            if not (schedule_period.start_date <= date <= schedule_period.end_date):
                raise serializers.ValidationError(
                    f'Date must be within period range'
                )
        
        if date and date < timezone.now().date():
            raise serializers.ValidationError('Cannot suggest shifts for past dates')
        
        return data


class ShiftSuggestionAcceptSerializer(serializers.Serializer):
    pass


class ShiftSuggestionDeclineSerializer(serializers.Serializer):
    decline_reason = serializers.CharField(required=False, allow_blank=True)
```

# ==== apps/shifts/tasks.py ====

```python
from celery import shared_task
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.conf import settings
from django.utils.html import strip_tags


@shared_task
def send_new_request_email(request_id):
    from .models import ShiftRequest
    try:
        shift_request = ShiftRequest.objects.get(id=request_id)
        admin_users = shift_request.requested_by.__class__.objects.filter(role='ADMIN')
        
        for admin in admin_users:
            context = {
                'pa_name': shift_request.requested_by.get_full_name(),
                'date': shift_request.date.strftime('%B %d, %Y'),
                'start_time': shift_request.start_time.strftime('%I:%M %p'),
                'end_time': shift_request.end_time.strftime('%I:%M %p'),
                'duration': shift_request.duration_hours,
                'notes': shift_request.notes,
                'period_name': shift_request.schedule_period.name,
            }
            
            html_message = render_to_string('emails/new_request_admin.html', context)
            plain_message = render_to_string('emails/new_request_admin.txt', context)
            
            send_mail(
                subject=f'New Shift Request from {shift_request.requested_by.get_full_name()}',
                message=plain_message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[admin.email],
                html_message=html_message,
                fail_silently=False,
            )
    except Exception as e:
        print(f"Error sending new request email: {e}")


@shared_task
def send_shift_approved_email(shift_id):
    from .models import ShiftRequest
    try:
        shift = ShiftRequest.objects.get(id=shift_id)
        
        context = {
            'pa_name': shift.requested_by.first_name,
            'admin_name': shift.approved_by.get_full_name() if shift.approved_by else 'Admin',
            'date': shift.date.strftime('%B %d, %Y'),
            'start_time': shift.start_time.strftime('%I:%M %p'),
            'end_time': shift.end_time.strftime('%I:%M %p'),
            'duration': shift.duration_hours,
            'period_name': shift.schedule_period.name,
            'admin_notes': shift.admin_notes,
            'schedule_url': f'{settings.FRONTEND_URL}/schedule',
        }
        
        html_message = render_to_string('emails/shift_approved.html', context)
        plain_message = render_to_string('emails/shift_approved.txt', context)
        
        send_mail(
            subject='Your Shift Request Has Been Approved',
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[shift.requested_by.email],
            html_message=html_message,
            fail_silently=False,
        )
    except Exception as e:
        print(f"Error sending approval email: {e}")


@shared_task
def send_shift_rejected_email(shift_id):
    from .models import ShiftRequest
    try:
        shift = ShiftRequest.objects.get(id=shift_id)
        
        context = {
            'pa_name': shift.requested_by.first_name,
            'date': shift.date.strftime('%B %d, %Y'),
            'start_time': shift.start_time.strftime('%I:%M %p'),
            'end_time': shift.end_time.strftime('%I:%M %p'),
            'duration': shift.duration_hours,
            'period_name': shift.schedule_period.name,
            'rejected_reason': shift.rejected_reason,
            'new_request_url': f'{settings.FRONTEND_URL}/requests/new',
        }
        
        html_message = render_to_string('emails/shift_rejected.html', context)
        plain_message = render_to_string('emails/shift_rejected.txt', context)
        
        send_mail(
            subject='Shift Request Not Approved',
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[shift.requested_by.email],
            html_message=html_message,
            fail_silently=False,
        )
    except Exception as e:
        print(f"Error sending rejection email: {e}")


@shared_task
def send_shift_suggestion_email(suggestion_id):
    from .models import ShiftSuggestion
    try:
        suggestion = ShiftSuggestion.objects.get(id=suggestion_id)
        
        context = {
            'pa_name': suggestion.suggested_to.first_name,
            'admin_name': suggestion.suggested_by.get_full_name(),
            'date': suggestion.date.strftime('%B %d, %Y'),
            'start_time': suggestion.start_time.strftime('%I:%M %p'),
            'end_time': suggestion.end_time.strftime('%I:%M %p'),
            'duration': suggestion.duration_hours,
            'message': suggestion.message,
            'dashboard_url': f'{settings.FRONTEND_URL}/dashboard',
        }
        
        html_message = render_to_string('emails/shift_suggested.html', context)
        plain_message = render_to_string('emails/shift_suggested.txt', context)
        
        send_mail(
            subject=f'Shift Suggestion from {suggestion.suggested_by.get_full_name()}',
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[suggestion.suggested_to.email],
            html_message=html_message,
            fail_silently=False,
        )
    except Exception as e:
        print(f"Error sending suggestion email: {e}")


@shared_task
def notify_admin_suggestion_accepted(suggestion_id):
    from .models import ShiftSuggestion
    try:
        suggestion = ShiftSuggestion.objects.get(id=suggestion_id)
        
        context = {
            'admin_name': suggestion.suggested_by.first_name,
            'pa_name': suggestion.suggested_to.get_full_name(),
            'date': suggestion.date.strftime('%B %d, %Y'),
            'start_time': suggestion.start_time.strftime('%I:%M %p'),
            'end_time': suggestion.end_time.strftime('%I:%M %p'),
            'requests_url': f'{settings.FRONTEND_URL}/requests',
        }
        
        html_message = render_to_string('emails/suggestion_accepted.html', context)
        plain_message = render_to_string('emails/suggestion_accepted.txt', context)
        
        send_mail(
            subject=f'{suggestion.suggested_to.get_full_name()} Accepted Your Shift Suggestion',
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[suggestion.suggested_by.email],
            html_message=html_message,
            fail_silently=False,
        )
    except Exception as e:
        print(f"Error sending accepted notification: {e}")


@shared_task
def notify_admin_suggestion_declined(suggestion_id):
    from .models import ShiftSuggestion
    try:
        suggestion = ShiftSuggestion.objects.get(id=suggestion_id)
        
        context = {
            'admin_name': suggestion.suggested_by.first_name,
            'pa_name': suggestion.suggested_to.get_full_name(),
            'date': suggestion.date.strftime('%B %d, %Y'),
            'start_time': suggestion.start_time.strftime('%I:%M %p'),
            'end_time': suggestion.end_time.strftime('%I:%M %p'),
            'reason': suggestion.decline_reason,
        }
        
        html_message = render_to_string('emails/suggestion_declined.html', context)
        plain_message = render_to_string('emails/suggestion_declined.txt', context)
        
        send_mail(
            subject=f'{suggestion.suggested_to.get_full_name()} Declined Your Shift Suggestion',
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[suggestion.suggested_by.email],
            html_message=html_message,
            fail_silently=False,
        )
    except Exception as e:
        print(f"Error sending declined notification: {e}")


@shared_task
def send_shift_edited_notification(shift_id, old_date, old_start_time, old_end_time):
    from .models import ShiftRequest
    from datetime import datetime
    try:
        shift = ShiftRequest.objects.get(id=shift_id)
        
        old_date_formatted = datetime.strptime(old_date, '%Y-%m-%d').strftime('%B %d, %Y')
        old_start_formatted = datetime.strptime(old_start_time, '%H:%M:%S').strftime('%I:%M %p')
        old_end_formatted = datetime.strptime(old_end_time, '%H:%M:%S').strftime('%I:%M %p')
        
        context = {
            'pa_name': shift.requested_by.first_name,
            'old_date': old_date_formatted,
            'old_start_time': old_start_formatted,
            'old_end_time': old_end_formatted,
            'new_date': shift.date.strftime('%B %d, %Y'),
            'new_start_time': shift.start_time.strftime('%I:%M %p'),
            'new_end_time': shift.end_time.strftime('%I:%M %p'),
            'admin_notes': shift.admin_notes,
            'schedule_url': f'{settings.FRONTEND_URL}/schedule',
        }
        
        html_message = render_to_string('emails/shift_edited.html', context)
        plain_message = render_to_string('emails/shift_edited.txt', context)
        
        send_mail(
            subject='Your Shift Has Been Updated',
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[shift.requested_by.email],
            html_message=html_message,
            fail_silently=False,
        )
    except Exception as e:
        print(f"Error sending shift edited email: {e}")


@shared_task
def send_shift_cancelled_by_pa_notification(shift_id, cancellation_reason):
    from .models import ShiftRequest
    try:
        shift = ShiftRequest.objects.get(id=shift_id)
        admin_users = shift.requested_by.__class__.objects.filter(role='ADMIN')
        
        coverage_warning = ''
        from datetime import time
        if (shift.start_time <= time(6, 0) and shift.end_time >= time(9, 0)):
            coverage_warning = 'âš ï¸ WARNING: This shift covered the critical MORNING time slot (6-9 AM). This date may now have a coverage gap.'
        elif (shift.start_time <= time(21, 0) and shift.end_time >= time(22, 0)):
            coverage_warning = 'âš ï¸ WARNING: This shift covered the critical EVENING time slot (9-10 PM). This date may now have a coverage gap.'
        
        for admin in admin_users:
            context = {
                'admin_name': admin.first_name,
                'pa_name': shift.requested_by.get_full_name(),
                'date': shift.date.strftime('%B %d, %Y'),
                'start_time': shift.start_time.strftime('%I:%M %p'),
                'end_time': shift.end_time.strftime('%I:%M %p'),
                'duration': shift.duration_hours,
                'cancellation_reason': cancellation_reason,
                'coverage_warning': coverage_warning,
                'schedule_url': f'{settings.FRONTEND_URL}/schedule',
            }
            
            html_message = render_to_string('emails/shift_cancelled_by_pa.html', context)
            plain_message = render_to_string('emails/shift_cancelled_by_pa.txt', context)
            
            send_mail(
                subject=f'âš ï¸ Shift Cancelled by {shift.requested_by.get_full_name()}',
                message=plain_message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[admin.email],
                html_message=html_message,
                fail_silently=False,
            )
    except Exception as e:
        print(f"Error sending PA cancellation email: {e}")


@shared_task
def send_shift_cancelled_by_admin_notification(shift_id, cancellation_reason):
    from .models import ShiftRequest
    try:
        shift = ShiftRequest.objects.get(id=shift_id)
        
        context = {
            'pa_name': shift.requested_by.first_name,
            'date': shift.date.strftime('%B %d, %Y'),
            'start_time': shift.start_time.strftime('%I:%M %p'),
            'end_time': shift.end_time.strftime('%I:%M %p'),
            'cancellation_reason': cancellation_reason,
            'schedule_url': f'{settings.FRONTEND_URL}/schedule',
        }
        
        html_message = render_to_string('emails/shift_cancelled_by_admin.html', context)
        plain_message = render_to_string('emails/shift_cancelled_by_admin.txt', context)
        
        send_mail(
            subject='Your Shift Has Been Cancelled',
            message=plain_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[shift.requested_by.email],
            html_message=html_message,
            fail_silently=False,
        )
    except Exception as e:
        print(f"Error sending admin cancellation email: {e}")
```

# ==== apps/shifts/templates/emails/new_request_admin.txt ====

```
```
ðŸ”” NEW SHIFT REQUEST

Hi Admin,

{{ pa_name }} has submitted a new shift request that requires your review.

SHIFT REQUEST DETAILS
---------------------
PA: {{ pa_name }} ({{ pa_email }})
Date: {{ shift_date }}
Time: {{ start_time }} - {{ end_time }}
Duration: {{ duration }} hours
Schedule Period: {{ period_name }}
{% if pa_notes %}
PA Notes: {{ pa_notes }}
{% endif %}
Submitted: {{ submitted_at }}

Please review and approve or reject this request at your earliest convenience:
{{ frontend_url }}/admin/approve

Best regards,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/shifts/templates/emails/shift_approved.txt ====

```
âœ… SHIFT REQUEST APPROVED

Hi {{ pa_name }},

Great news! Your shift request has been approved by {{ admin_name }}.

SHIFT DETAILS
-------------
Date: {{ shift_date }}
Time: {{ start_time }} - {{ end_time }}
Duration: {{ duration }} hours
Schedule Period: {{ period_name }}
{% if admin_notes %}
Admin Notes: {{ admin_notes }}
{% endif %}

This shift is now part of your schedule. You can view your complete schedule at:
{{ frontend_url }}/schedule

If you have any questions, please contact your administrator.

Thank you,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/shifts/templates/emails/shift_cancelled_by_admin.txt ====

```


SHIFT CANCELLED

Hi {{ pa_name }},

Your shift has been cancelled by an administrator.

CANCELLED SHIFT DETAILS
------------------------
Date: {{ date }}
Time: {{ start_time }} - {{ end_time }}

{% if cancellation_reason %}REASON FOR CANCELLATION
-----------------------
{{ cancellation_reason }}
{% endif %}

You can view your updated schedule here:
{{ schedule_url }}

If you have any questions about this cancellation, please contact your administrator.

Thank you,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/shifts/templates/emails/shift_cancelled_by_pa.txt ====

```
âš ï¸ SHIFT CANCELLED BY PA

Hi {{ admin_name }},

{{ pa_name }} has cancelled one of their approved shifts.

CANCELLED SHIFT DETAILS
------------------------
PA: {{ pa_name }}
Date: {{ date }}
Time: {{ start_time }} - {{ end_time }}
Duration: {{ duration }} hours

{% if cancellation_reason %}REASON FOR CANCELLATION
-----------------------
{{ cancellation_reason }}
{% endif %}

{% if coverage_warning %}
{{ coverage_warning }}
{% endif %}

Please review the schedule and reassign this shift if needed:
{{ schedule_url }}

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/shifts/templates/emails/shift_edited.txt ====

```
âœï¸ SHIFT UPDATED

Hi {{ pa_name }},

An admin has updated one of your shifts. Please review the changes below.

ORIGINAL SHIFT
--------------
Date: {{ old_date }}
Time: {{ old_start_time }} - {{ old_end_time }}

NEW SHIFT DETAILS
-----------------
Date: {{ new_date }}
Time: {{ new_start_time }} - {{ new_end_time }}

{% if admin_notes %}ADMIN NOTES
-----------
{{ admin_notes }}
{% endif %}

Please check your updated schedule here:
{{ schedule_url }}

If you have any questions about this change, please contact your administrator.

Thank you,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/shifts/templates/emails/shift_rejected.txt ====

```
 SHIFT REQUEST NOT APPROVED

Hi {{ pa_name }},

Your shift request was not approved. Please see the details below.

SHIFT DETAILS
-------------
Date: {{ shift_date }}
Time: {{ start_time }} - {{ end_time }}
Duration: {{ duration }} hours
Schedule Period: {{ period_name }}

REASON FOR REJECTION
--------------------
{{ rejected_reason }}

If you have questions about this decision or would like to request a different shift, please contact your administrator or submit a new request at:
{{ frontend_url }}/requests/new

Thank you for your understanding.

Best regards,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/shifts/templates/emails/shift_suggested.txt ====

```
Shift Suggestion from {{ admin_name }}

Hi {{ pa_name }},

{{ admin_name }} has suggested you work a shift:

Date: {{ date }}
Time: {{ start_time }} - {{ end_time }} ({{ duration }} hours)
{% if message %}Message: {{ message }}{% endif %}

You can accept or decline this suggestion from your dashboard:
{{ dashboard_url }}

Note: If you accept, a shift request will be created and must still be approved by the admin.

---
This is an automated message from the PA Scheduling System.
```

# ==== apps/shifts/templates/emails/suggestion_accepted.txt ====

```
Suggestion Accepted

Hi {{ admin_name }},

{{ pa_name }} has accepted your shift suggestion:

Date: {{ date }}
Time: {{ start_time }} - {{ end_time }}

A shift request has been automatically created and is pending your approval.

Review the request here: {{ requests_url }}

---
This is an automated message from the PA Scheduling System.
```

# ==== apps/shifts/templates/emails/suggestion_declined.txt ====

```
Suggestion Declined

Hi {{ admin_name }},

{{ pa_name }} has declined your shift suggestion:

Date: {{ date }}
Time: {{ start_time }} - {{ end_time }}
{% if reason %}
Reason: {{ reason }}
{% endif %}

You can suggest this shift to another PA if needed.

---
This is an automated message from the PA Scheduling System.
```

# ==== apps/shifts/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/shifts/urls.py ====

```python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ShiftRequestViewSet, ShiftSuggestionViewSet

router = DefaultRouter()
router.register(r'requests', ShiftRequestViewSet, basename='shift-request')
router.register(r'suggestions', ShiftSuggestionViewSet, basename='shift-suggestion')

urlpatterns = [
    path('', include(router.urls)),
]
```

# ==== apps/shifts/views.py ====

```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.utils import timezone
from datetime import datetime, timedelta
from .models import ShiftRequest, ShiftSuggestion
from .serializers import (
    ShiftRequestSerializer, 
    ShiftRequestCreateSerializer,
    ShiftSuggestionSerializer, 
    ShiftSuggestionCreateSerializer,
    ShiftSuggestionAcceptSerializer, 
    ShiftSuggestionDeclineSerializer
)
from .tasks import (
    send_new_request_email, 
    send_shift_approved_email, 
    send_shift_rejected_email,
    send_shift_suggestion_email, 
    notify_admin_suggestion_accepted, 
    notify_admin_suggestion_declined,
    send_shift_edited_notification,
    send_shift_cancelled_by_pa_notification,
    send_shift_cancelled_by_admin_notification
)


def check_time_conflict(date, start_time, end_time, exclude_shift_id=None):
    """
    Check if requested time conflicts with any APPROVED shift.
    Only APPROVED shifts block new requests (PENDING doesn't block).
    
    Returns: (has_conflict: bool, conflicting_shift: ShiftRequest or None)
    """
    conflicts = ShiftRequest.objects.filter(
        date=date,
        status='APPROVED'
    )
    
    if exclude_shift_id:
        conflicts = conflicts.exclude(id=exclude_shift_id)
    
    requested_start = datetime.combine(date, start_time)
    requested_end = datetime.combine(date, end_time)
    
    if requested_end <= requested_start:
        requested_end += timedelta(days=1)
    
    for shift in conflicts:
        shift_start = datetime.combine(shift.date, shift.start_time)
        shift_end = datetime.combine(shift.date, shift.end_time)
        
        if shift_end <= shift_start:
            shift_end += timedelta(days=1)
        
        if requested_start < shift_end and requested_end > shift_start:
            return True, shift
    
    return False, None


class ShiftRequestViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        user = self.request.user
        if user.role == 'ADMIN':
            return ShiftRequest.objects.all()
        return ShiftRequest.objects.filter(requested_by=user)
    
    def get_serializer_class(self):
        if self.action == 'create':
            return ShiftRequestCreateSerializer
        return ShiftRequestSerializer
    
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        date = serializer.validated_data['date']
        start_time = serializer.validated_data['start_time']
        end_time = serializer.validated_data['end_time']
        
        has_conflict, conflicting_shift = check_time_conflict(date, start_time, end_time)
        
        if has_conflict:
            return Response({
                'error': 'Time slot already taken',
                'detail': f'This time conflicts with an approved shift by {conflicting_shift.requested_by.get_full_name()} ({conflicting_shift.start_time.strftime("%I:%M %p")} - {conflicting_shift.end_time.strftime("%I:%M %p")})',
                'conflict': {
                    'shift_id': conflicting_shift.id,
                    'pa_name': conflicting_shift.requested_by.get_full_name(),
                    'date': str(conflicting_shift.date),
                    'start_time': str(conflicting_shift.start_time),
                    'end_time': str(conflicting_shift.end_time)
                }
            }, status=status.HTTP_400_BAD_REQUEST)
        
        self.perform_create(serializer)
        headers = self.get_success_url(serializer) if hasattr(self, 'get_success_url') else {}
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)
    
    def perform_create(self, serializer):
        shift_request = serializer.save(requested_by=self.request.user)
        send_new_request_email.delay(shift_request.id)
    
    @action(detail=True, methods=['post'])
    def approve(self, request, pk=None):
        if request.user.role != 'ADMIN':
            return Response({'error': 'Admin access required'}, status=status.HTTP_403_FORBIDDEN)
        
        shift_request = self.get_object()
        if shift_request.status != 'PENDING':
            return Response({'error': 'Can only approve pending requests'}, status=status.HTTP_400_BAD_REQUEST)
        
        has_conflict, conflicting_shift = check_time_conflict(
            shift_request.date,
            shift_request.start_time,
            shift_request.end_time,
            exclude_shift_id=shift_request.id
        )
        
        if has_conflict:
            return Response({
                'error': 'Cannot approve - time slot conflict',
                'detail': f'This shift conflicts with an existing approved shift by {conflicting_shift.requested_by.get_full_name()} ({conflicting_shift.start_time.strftime("%I:%M %p")} - {conflicting_shift.end_time.strftime("%I:%M %p")})',
                'conflict': {
                    'shift_id': conflicting_shift.id,
                    'pa_name': conflicting_shift.requested_by.get_full_name(),
                    'date': str(conflicting_shift.date),
                    'start_time': str(conflicting_shift.start_time),
                    'end_time': str(conflicting_shift.end_time)
                }
            }, status=status.HTTP_400_BAD_REQUEST)
        
        shift_request.status = 'APPROVED'
        shift_request.approved_by = request.user
        shift_request.approved_at = timezone.now()
        shift_request.admin_notes = request.data.get('admin_notes', '')
        shift_request.save()
        
        send_shift_approved_email.delay(shift_request.id)
        
        return Response(ShiftRequestSerializer(shift_request).data)
    
    @action(detail=True, methods=['post'])
    def reject(self, request, pk=None):
        if request.user.role != 'ADMIN':
            return Response({'error': 'Admin access required'}, status=status.HTTP_403_FORBIDDEN)
        
        shift_request = self.get_object()
        if shift_request.status != 'PENDING':
            return Response({'error': 'Can only reject pending requests'}, status=status.HTTP_400_BAD_REQUEST)
        
        shift_request.status = 'REJECTED'
        shift_request.rejected_reason = request.data.get('rejected_reason', '')
        shift_request.save()
        
        send_shift_rejected_email.delay(shift_request.id)
        
        return Response(ShiftRequestSerializer(shift_request).data)
    
    @action(detail=True, methods=['patch'])
    def edit(self, request, pk=None):
        if request.user.role != 'ADMIN':
            return Response({'error': 'Admin access required'}, status=status.HTTP_403_FORBIDDEN)
        
        shift_request = self.get_object()
        
        if shift_request.status != 'APPROVED':
            return Response({'error': 'Can only edit approved shifts'}, status=status.HTTP_400_BAD_REQUEST)
        
        new_date = request.data.get('date')
        new_start_time = request.data.get('start_time')
        new_end_time = request.data.get('end_time')
        admin_notes = request.data.get('admin_notes', '')
        
        if not all([new_date, new_start_time, new_end_time]):
            return Response({'error': 'date, start_time, and end_time are required'}, status=status.HTTP_400_BAD_REQUEST)
        
        if isinstance(new_date, str):
            new_date = datetime.strptime(new_date, '%Y-%m-%d').date()
        if isinstance(new_start_time, str):
            new_start_time = datetime.strptime(new_start_time, '%H:%M').time()
        if isinstance(new_end_time, str):
            new_end_time = datetime.strptime(new_end_time, '%H:%M').time()
        
        has_conflict, conflicting_shift = check_time_conflict(
            new_date,
            new_start_time,
            new_end_time,
            exclude_shift_id=shift_request.id
        )
        
        if has_conflict:
            return Response({
                'error': 'Time slot conflict',
                'detail': f'This time conflicts with an approved shift by {conflicting_shift.requested_by.get_full_name()} ({conflicting_shift.start_time.strftime("%I:%M %p")} - {conflicting_shift.end_time.strftime("%I:%M %p")})',
                'conflict': {
                    'shift_id': conflicting_shift.id,
                    'pa_name': conflicting_shift.requested_by.get_full_name(),
                    'date': str(conflicting_shift.date),
                    'start_time': str(conflicting_shift.start_time),
                    'end_time': str(conflicting_shift.end_time)
                }
            }, status=status.HTTP_400_BAD_REQUEST)
        
        old_date = str(shift_request.date)
        old_start_time = str(shift_request.start_time)
        old_end_time = str(shift_request.end_time)
        
        shift_request.date = new_date
        shift_request.start_time = new_start_time
        shift_request.end_time = new_end_time
        shift_request.admin_notes = admin_notes
        shift_request.save()
        
        send_shift_edited_notification.delay(shift_request.id, old_date, old_start_time, old_end_time)
        
        return Response(ShiftRequestSerializer(shift_request).data)
    
    @action(detail=True, methods=['post'])
    def cancel(self, request, pk=None):
        shift_request = self.get_object()
        cancellation_reason = request.data.get('cancellation_reason', '')
        
        if shift_request.status not in ['PENDING', 'APPROVED']:
            return Response({'error': 'Can only cancel pending or approved shifts'}, status=status.HTTP_400_BAD_REQUEST)
        
        is_admin = request.user.role == 'ADMIN'
        is_owner = shift_request.requested_by == request.user
        
        if not is_admin and not is_owner:
            return Response({'error': 'Can only cancel own shifts'}, status=status.HTTP_403_FORBIDDEN)
        
        shift_request.status = 'CANCELLED'
        shift_request.cancellation_reason = cancellation_reason
        shift_request.save()
        
        if is_owner and not is_admin:
            send_shift_cancelled_by_pa_notification.delay(shift_request.id, cancellation_reason)
        elif is_admin:
            send_shift_cancelled_by_admin_notification.delay(shift_request.id, cancellation_reason)
        
        return Response(ShiftRequestSerializer(shift_request).data)


class ShiftSuggestionViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    
    def get_queryset(self):
        user = self.request.user
        if user.role == 'ADMIN':
            return ShiftSuggestion.objects.filter(suggested_by=user)
        return ShiftSuggestion.objects.filter(suggested_to=user)
    
    def get_serializer_class(self):
        if self.action == 'create':
            return ShiftSuggestionCreateSerializer
        elif self.action == 'accept':
            return ShiftSuggestionAcceptSerializer
        elif self.action == 'decline':
            return ShiftSuggestionDeclineSerializer
        return ShiftSuggestionSerializer
    
    def create(self, request, *args, **kwargs):
        if request.user.role != 'ADMIN':
            return Response({'error': 'Admin access required'}, status=status.HTTP_403_FORBIDDEN)
        
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        date = serializer.validated_data['date']
        start_time = serializer.validated_data['start_time']
        end_time = serializer.validated_data['end_time']
        
        has_conflict, conflicting_shift = check_time_conflict(date, start_time, end_time)
        
        if has_conflict:
            return Response({
                'error': 'Time slot already taken',
                'detail': f'This time conflicts with an approved shift by {conflicting_shift.requested_by.get_full_name()} ({conflicting_shift.start_time.strftime("%I:%M %p")} - {conflicting_shift.end_time.strftime("%I:%M %p")})',
                'conflict': {
                    'shift_id': conflicting_shift.id,
                    'pa_name': conflicting_shift.requested_by.get_full_name(),
                    'date': str(conflicting_shift.date),
                    'start_time': str(conflicting_shift.start_time),
                    'end_time': str(conflicting_shift.end_time)
                }
            }, status=status.HTTP_400_BAD_REQUEST)
        
        suggestion = serializer.save(suggested_by=request.user)
        send_shift_suggestion_email.delay(suggestion.id)
        
        return Response(ShiftSuggestionSerializer(suggestion).data, status=status.HTTP_201_CREATED)
    
    @action(detail=True, methods=['post'])
    def accept(self, request, pk=None):
        suggestion = self.get_object()
        
        if suggestion.suggested_to != request.user:
            return Response({'error': 'Can only accept own suggestions'}, status=status.HTTP_403_FORBIDDEN)
        
        if suggestion.status != 'PENDING':
            return Response({'error': 'Suggestion already responded to'}, status=status.HTTP_400_BAD_REQUEST)
        
        has_conflict, conflicting_shift = check_time_conflict(
            suggestion.date,
            suggestion.start_time,
            suggestion.end_time
        )
        
        if has_conflict:
            return Response({
                'error': 'Cannot accept - time slot now taken',
                'detail': f'This time now conflicts with an approved shift by {conflicting_shift.requested_by.get_full_name()} ({conflicting_shift.start_time.strftime("%I:%M %p")} - {conflicting_shift.end_time.strftime("%I:%M %p")}). The shift was approved after this suggestion was created.',
                'conflict': {
                    'shift_id': conflicting_shift.id,
                    'pa_name': conflicting_shift.requested_by.get_full_name(),
                    'date': str(conflicting_shift.date),
                    'start_time': str(conflicting_shift.start_time),
                    'end_time': str(conflicting_shift.end_time)
                }
            }, status=status.HTTP_400_BAD_REQUEST)
        
        shift_request = ShiftRequest.objects.create(
            schedule_period=suggestion.schedule_period,
            requested_by=request.user,
            date=suggestion.date,
            start_time=suggestion.start_time,
            end_time=suggestion.end_time,
            notes=f"Accepted suggestion from {suggestion.suggested_by.get_full_name()}"
        )
        
        suggestion.status = 'ACCEPTED'
        suggestion.responded_at = timezone.now()
        suggestion.related_shift_request = shift_request
        suggestion.save()
        
        notify_admin_suggestion_accepted.delay(suggestion.id)
        
        return Response(ShiftSuggestionSerializer(suggestion).data)
    
    @action(detail=True, methods=['post'])
    def decline(self, request, pk=None):
        suggestion = self.get_object()
        
        if suggestion.suggested_to != request.user:
            return Response({'error': 'Can only decline own suggestions'}, status=status.HTTP_403_FORBIDDEN)
        
        if suggestion.status != 'PENDING':
            return Response({'error': 'Suggestion already responded to'}, status=status.HTTP_400_BAD_REQUEST)
        
        serializer = ShiftSuggestionDeclineSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        suggestion.status = 'DECLINED'
        suggestion.responded_at = timezone.now()
        suggestion.decline_reason = serializer.validated_data.get('decline_reason', '')
        suggestion.save()
        
        notify_admin_suggestion_declined.delay(suggestion.id)
        
        return Response(ShiftSuggestionSerializer(suggestion).data)
```

# ==== apps/users/__init__.py ====

```python

```

# ==== apps/users/admin.py ====

```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from .models import User, EmailVerificationToken, PasswordResetToken


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    list_display = ['email', 'username', 'first_name', 'last_name', 'role', 'is_email_verified', 'is_active']
    list_filter = ['role', 'is_email_verified', 'is_active', 'date_joined']
    search_fields = ['email', 'username', 'first_name', 'last_name']
    ordering = ['-date_joined']
    
    fieldsets = (
        (None, {'fields': ('email', 'username', 'password')}),
        ('Personal Info', {'fields': ('first_name', 'last_name', 'phone_number')}),
        ('Permissions', {'fields': ('role', 'is_active', 'is_staff', 'is_superuser', 'is_email_verified')}),
        ('Important dates', {'fields': ('last_login', 'date_joined')}),
    )
    
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('email', 'username', 'password1', 'password2', 'first_name', 'last_name', 'phone_number', 'role'),
        }),
    )


@admin.register(EmailVerificationToken)
class EmailVerificationTokenAdmin(admin.ModelAdmin):
    list_display = ['user', 'token', 'created_at', 'expires_at', 'used']
    list_filter = ['used', 'created_at']
    search_fields = ['user__email', 'token']
    readonly_fields = ['token', 'created_at']


@admin.register(PasswordResetToken)
class PasswordResetTokenAdmin(admin.ModelAdmin):
    list_display = ['user', 'token', 'created_at', 'expires_at', 'used']
    list_filter = ['used', 'created_at']
    search_fields = ['user__email', 'token']
    readonly_fields = ['token', 'created_at']
```

# ==== apps/users/apps.py ====

```python
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.users'
    
    def ready(self):
        import apps.users.signals
```

# ==== apps/users/emails.py ====

```python
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.conf import settings
from celery import shared_task
import logging

logger = logging.getLogger(__name__)


@shared_task(bind=True, max_retries=3)
def send_verification_email(self, user_id, token):
    """
    Send email verification link to new user.
    """
    try:
        from apps.users.models import User
        
        user = User.objects.get(id=user_id)
        
        # Build verification URL
        verification_url = f"{settings.FRONTEND_URL}/verify-email?token={token}"
        
        # Context for email templates
        context = {
            'user_name': user.get_full_name() or user.email,
            'verification_url': verification_url,
        }
        
        # Render HTML and text versions
        html_message = render_to_string('emails/verification.html', context)
        text_message = render_to_string('emails/verification.txt', context)
        
        # Send email
        send_mail(
            subject='âœ‰ï¸ Verify Your Email - PA Scheduling System',
            message=text_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[user.email],
            html_message=html_message,
            fail_silently=False,
        )
        
        logger.info(f'Verification email sent to {user.email}')
        return f'Email sent to {user.email}'
        
    except Exception as e:
        logger.error(f'Failed to send verification email: {e}')
        raise self.retry(exc=e, countdown=60 * (2 ** self.request.retries))


@shared_task(bind=True, max_retries=3)
def send_password_reset_email(self, user_id, token):
    """
    Send password reset link to user.
    """
    try:
        from apps.users.models import User
        
        user = User.objects.get(id=user_id)
        
        # Build reset URL
        reset_url = f"{settings.FRONTEND_URL}/reset-password?token={token}"
        
        # Context for email templates
        context = {
            'user_name': user.get_full_name() or user.email,
            'reset_url': reset_url,
        }
        
        # Render HTML and text versions
        html_message = render_to_string('emails/password_reset.html', context)
        text_message = render_to_string('emails/password_reset.txt', context)
        
        # Send email
        send_mail(
            subject='ðŸ” Password Reset - PA Scheduling System',
            message=text_message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[user.email],
            html_message=html_message,
            fail_silently=False,
        )
        
        logger.info(f'Password reset email sent to {user.email}')
        return f'Email sent to {user.email}'
        
    except Exception as e:
        logger.error(f'Failed to send password reset email: {e}')
        raise self.retry(exc=e, countdown=60 * (2 ** self.request.retries))
```

# ==== apps/users/migrations/0001_initial.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 17:33

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('email', models.EmailField(db_index=True, max_length=254, unique=True)),
                ('phone_number', models.CharField(max_length=20)),
                ('role', models.CharField(choices=[('ADMIN', 'Admin'), ('PA', 'Personal Assistant')], default='PA', max_length=10)),
                ('is_email_verified', models.BooleanField(default=False)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'User',
                'verbose_name_plural': 'Users',
                'db_table': 'users',
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]
```

# ==== apps/users/migrations/0002_emailverificationtoken_passwordresettoken.py ====

```python
# Generated by Django 5.2.7 on 2025-10-31 18:04

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('users', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='EmailVerificationToken',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('token', models.UUIDField(default=uuid.uuid4, editable=False, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField()),
                ('used', models.BooleanField(default=False)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='verification_tokens', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'email_verification_tokens',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateModel(
            name='PasswordResetToken',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('token', models.UUIDField(default=uuid.uuid4, editable=False, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('expires_at', models.DateTimeField()),
                ('used', models.BooleanField(default=False)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='password_reset_tokens', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'db_table': 'password_reset_tokens',
                'ordering': ['-created_at'],
            },
        ),
    ]
```

# ==== apps/users/migrations/0003_paprofile_paschedulestats.py ====

```python
# Generated by Django 5.2.7 on 2025-11-02 17:24

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('users', '0002_emailverificationtoken_passwordresettoken'),
    ]

    operations = [
        migrations.CreateModel(
            name='PAProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('preferred_start_time', models.TimeField(blank=True, help_text='Preferred shift start time (e.g., 08:00)', null=True)),
                ('preferred_end_time', models.TimeField(blank=True, help_text='Preferred shift end time (e.g., 16:00)', null=True)),
                ('preferred_days', models.JSONField(blank=True, default=list, help_text='List of preferred days: ["monday", "tuesday", ...]')),
                ('max_hours_per_week', models.IntegerField(default=40, help_text='Maximum hours this PA can work per week')),
                ('notes', models.TextField(blank=True, help_text='Internal notes about this PA (admin only)')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('user', models.OneToOneField(limit_choices_to={'role': 'PA'}, on_delete=django.db.models.deletion.CASCADE, related_name='pa_profile', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'PA Profile',
                'verbose_name_plural': 'PA Profiles',
                'db_table': 'pa_profiles',
            },
        ),
        migrations.CreateModel(
            name='PAScheduleStats',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('total_shifts_worked', models.IntegerField(default=0)),
                ('total_hours_worked', models.DecimalField(decimal_places=2, default=0, max_digits=8)),
                ('average_hours_per_week', models.DecimalField(decimal_places=2, default=0, max_digits=5)),
                ('most_common_days', models.JSONField(blank=True, default=dict, help_text='{"monday": 15, "wednesday": 12, ...}')),
                ('most_common_start_time', models.TimeField(blank=True, null=True)),
                ('most_common_shift_length', models.DecimalField(blank=True, decimal_places=2, help_text='Average shift duration in hours', max_digits=4, null=True)),
                ('preferred_shift_pattern', models.CharField(blank=True, choices=[('morning', 'Morning (6-9 AM)'), ('evening', 'Evening (9-10 PM)'), ('full_day', 'Full Day'), ('mixed', 'Mixed')], max_length=20)),
                ('reliability_score', models.DecimalField(decimal_places=2, default=100.0, help_text='Percentage of completed shifts without cancellation (0-100)', max_digits=5)),
                ('typical_request_timing', models.IntegerField(blank=True, help_text='Average days before shift date that PA typically requests', null=True)),
                ('consecutive_days_preference', models.IntegerField(blank=True, help_text='Average number of consecutive days worked', null=True)),
                ('last_worked_date', models.DateField(blank=True, null=True)),
                ('last_calculated', models.DateTimeField(auto_now=True)),
                ('pa', models.OneToOneField(limit_choices_to={'role': 'PA'}, on_delete=django.db.models.deletion.CASCADE, related_name='schedule_stats', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'PA Schedule Statistics',
                'verbose_name_plural': 'PA Schedule Statistics',
                'db_table': 'pa_schedule_stats',
            },
        ),
    ]
```

# ==== apps/users/migrations/__init__.py ====

```python

```

# ==== apps/users/models.py ====

```python
from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils import timezone
import uuid
from datetime import timedelta


class User(AbstractUser):
    """
    Custom User model extending Django's AbstractUser.
    Email is the primary identifier instead of username.
    """
    email = models.EmailField(unique=True, db_index=True)
    phone_number = models.CharField(max_length=20)
    
    ROLE_CHOICES = [
        ('ADMIN', 'Admin'),
        ('PA', 'Personal Assistant'),
    ]
    role = models.CharField(max_length=10, choices=ROLE_CHOICES, default='PA')
    
    is_email_verified = models.BooleanField(default=False)
    
    # Make email the login field instead of username
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username', 'first_name', 'last_name']
    
    class Meta:
        db_table = 'users'
        verbose_name = 'User'
        verbose_name_plural = 'Users'
    
    def __str__(self):
        return f"{self.email} ({self.get_role_display()})"
    
    def save(self, *args, **kwargs):
        # Normalize email to lowercase
        if self.email:
            self.email = self.email.lower()
        super().save(*args, **kwargs)


class EmailVerificationToken(models.Model):
    """Token for email verification"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='verification_tokens')
    token = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    used = models.BooleanField(default=False)
    
    class Meta:
        db_table = 'email_verification_tokens'
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        if not self.expires_at:
            self.expires_at = timezone.now() + timedelta(days=7)
        super().save(*args, **kwargs)
    
    def is_valid(self):
        """Check if token is still valid"""
        return not self.used and timezone.now() < self.expires_at
    
    def __str__(self):
        return f"Verification token for {self.user.email}"


class PasswordResetToken(models.Model):
    """Token for password reset"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='password_reset_tokens')
    token = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    used = models.BooleanField(default=False)
    
    class Meta:
        db_table = 'password_reset_tokens'
        ordering = ['-created_at']
    
    def save(self, *args, **kwargs):
        if not self.expires_at:
            self.expires_at = timezone.now() + timedelta(hours=24)
        super().save(*args, **kwargs)
    
    def is_valid(self):
        """Check if token is still valid"""
        return not self.used and timezone.now() < self.expires_at
    
    def __str__(self):
        return f"Password reset token for {self.user.email}"


class PAProfile(models.Model):
    """
    Extended profile for PA users with preferences and scheduling settings.
    One-to-one relationship with User where role='PA'.
    """
    user = models.OneToOneField(
        User,
        on_delete=models.CASCADE,
        related_name='pa_profile',
        limit_choices_to={'role': 'PA'}
    )
    
    # Preferred working hours
    preferred_start_time = models.TimeField(
        null=True,
        blank=True,
        help_text="Preferred shift start time (e.g., 08:00)"
    )
    preferred_end_time = models.TimeField(
        null=True,
        blank=True,
        help_text="Preferred shift end time (e.g., 16:00)"
    )
    
    # Preferred working days (stored as JSON array)
    preferred_days = models.JSONField(
        default=list,
        blank=True,
        help_text='List of preferred days: ["monday", "tuesday", ...]'
    )
    
    # Weekly hour limit
    max_hours_per_week = models.IntegerField(
        default=40,
        help_text="Maximum hours this PA can work per week"
    )
    
    # Admin notes about this PA
    notes = models.TextField(
        blank=True,
        help_text="Internal notes about this PA (admin only)"
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'pa_profiles'
        verbose_name = 'PA Profile'
        verbose_name_plural = 'PA Profiles'
    
    def __str__(self):
        return f"Profile for {self.user.get_full_name()}"


class PAScheduleStats(models.Model):
    """
    Historical pattern tracking for each PA.
    Used by AI for predictive scheduling and conflict resolution.
    """
    pa = models.OneToOneField(
        User,
        on_delete=models.CASCADE,
        related_name='schedule_stats',
        limit_choices_to={'role': 'PA'}
    )
    
    # Lifetime statistics
    total_shifts_worked = models.IntegerField(default=0)
    total_hours_worked = models.DecimalField(max_digits=8, decimal_places=2, default=0)
    average_hours_per_week = models.DecimalField(max_digits=5, decimal_places=2, default=0)
    
    # Pattern data (stored as JSON)
    most_common_days = models.JSONField(
        default=dict,
        blank=True,
        help_text='{"monday": 15, "wednesday": 12, ...}'
    )
    most_common_start_time = models.TimeField(null=True, blank=True)
    most_common_shift_length = models.DecimalField(
        max_digits=4,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="Average shift duration in hours"
    )
    
    # Behavioral patterns
    preferred_shift_pattern = models.CharField(
        max_length=20,
        blank=True,
        choices=[
            ('morning', 'Morning (6-9 AM)'),
            ('evening', 'Evening (9-10 PM)'),
            ('full_day', 'Full Day'),
            ('mixed', 'Mixed'),
        ]
    )
    
    # Reliability metrics
    reliability_score = models.DecimalField(
        max_digits=5,
        decimal_places=2,
        default=100.0,
        help_text="Percentage of completed shifts without cancellation (0-100)"
    )
    
    # Request timing
    typical_request_timing = models.IntegerField(
        null=True,
        blank=True,
        help_text="Average days before shift date that PA typically requests"
    )
    consecutive_days_preference = models.IntegerField(
        null=True,
        blank=True,
        help_text="Average number of consecutive days worked"
    )
    
    # Last activity
    last_worked_date = models.DateField(null=True, blank=True)
    last_calculated = models.DateTimeField(auto_now=True)
    
    class Meta:
        db_table = 'pa_schedule_stats'
        verbose_name = 'PA Schedule Statistics'
        verbose_name_plural = 'PA Schedule Statistics'
    
    def __str__(self):
        return f"Stats for {self.pa.get_full_name()}"
```

# ==== apps/users/serializers.py ====

```python
from rest_framework import serializers
from django.contrib.auth import authenticate
from django.contrib.auth.password_validation import validate_password
from .models import User, PAProfile, PAScheduleStats  # <-- ADD PAProfile and PAScheduleStats here


class UserSerializer(serializers.ModelSerializer):
    """Serializer for User responses"""
    class Meta:
        model = User
        fields = ['id', 'email', 'username', 'first_name', 'last_name', 
                  'phone_number', 'role', 'is_email_verified', 'date_joined']
        read_only_fields = ['id', 'date_joined', 'is_email_verified']


class RegisterSerializer(serializers.ModelSerializer):
    """Serializer for user registration"""
    password = serializers.CharField(
        write_only=True, 
        required=True, 
        validators=[validate_password],
        style={'input_type': 'password'}
    )
    password_confirm = serializers.CharField(
        write_only=True, 
        required=True,
        style={'input_type': 'password'}
    )

    class Meta:
        model = User
        fields = ['email', 'username', 'password', 'password_confirm', 
                  'first_name', 'last_name', 'phone_number']

    def validate_email(self, value):
        """Ensure email is lowercase and unique"""
        value = value.lower()
        if User.objects.filter(email=value).exists():
            raise serializers.ValidationError("A user with this email already exists.")
        return value

    def validate(self, attrs):
        """Check that passwords match"""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({
                "password": "Password fields didn't match."
            })
        return attrs

    def create(self, validated_data):
        """Create new user with hashed password"""
        validated_data.pop('password_confirm')
        user = User.objects.create_user(
            email=validated_data['email'],
            username=validated_data['username'],
            password=validated_data['password'],
            first_name=validated_data.get('first_name', ''),
            last_name=validated_data.get('last_name', ''),
            phone_number=validated_data['phone_number'],
            role='PA'  # Default role is PA
        )
        return user


class LoginSerializer(serializers.Serializer):
    """Serializer for user login"""
    email = serializers.EmailField()
    password = serializers.CharField(
        write_only=True,
        style={'input_type': 'password'}
    )

    def validate_email(self, value):
        """Normalize email to lowercase"""
        return value.lower()

    def validate(self, attrs):
        """Authenticate user"""
        email = attrs.get('email')
        password = attrs.get('password')

        if email and password:
            # Try to authenticate
            user = authenticate(
                request=self.context.get('request'),
                username=email,  # We use email as username
                password=password
            )

            if not user:
                raise serializers.ValidationError(
                    'Unable to log in with provided credentials.',
                    code='authorization'
                )
            
            if not user.is_active:
                raise serializers.ValidationError(
                    'User account is disabled.',
                    code='authorization'
                )

            attrs['user'] = user
            return attrs
        else:
            raise serializers.ValidationError(
                'Must include "email" and "password".',
                code='authorization'
            )


class PasswordResetRequestSerializer(serializers.Serializer):
    """Serializer for requesting password reset"""
    email = serializers.EmailField()

    def validate_email(self, value):
        """Normalize email to lowercase"""
        return value.lower()


class PasswordResetConfirmSerializer(serializers.Serializer):
    """Serializer for confirming password reset"""
    token = serializers.UUIDField()
    password = serializers.CharField(
        write_only=True,
        required=True,
        validators=[validate_password],
        style={'input_type': 'password'}
    )
    password_confirm = serializers.CharField(
        write_only=True,
        required=True,
        style={'input_type': 'password'}
    )

    def validate(self, attrs):
        """Check that passwords match"""
        if attrs['password'] != attrs['password_confirm']:
            raise serializers.ValidationError({
                "password": "Password fields didn't match."
            })
        return attrs


class EmailVerificationSerializer(serializers.Serializer):
    """Serializer for email verification"""
    token = serializers.UUIDField()


class UserProfileUpdateSerializer(serializers.ModelSerializer):
    """Serializer for updating user profile"""
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'phone_number']

    def validate_phone_number(self, value):
        """Ensure phone number is provided"""
        if not value:
            raise serializers.ValidationError("Phone number is required.")
        return value
    
# ============= PA MANAGEMENT SERIALIZERS =============

class PAProfileSerializer(serializers.ModelSerializer):
    """Serializer for PA profile data"""
    class Meta:
        model = PAProfile
        fields = [
            'preferred_start_time',
            'preferred_end_time', 
            'preferred_days',
            'max_hours_per_week',
            'notes'
        ]


class PAScheduleStatsSerializer(serializers.ModelSerializer):
    """Serializer for PA statistics"""
    class Meta:
        model = PAScheduleStats
        fields = [
            'total_shifts_worked',
            'total_hours_worked',
            'average_hours_per_week',
            'most_common_days',
            'most_common_start_time',
            'most_common_shift_length',
            'preferred_shift_pattern',
            'reliability_score',
            'typical_request_timing',
            'consecutive_days_preference',
            'last_worked_date',
            'last_calculated'
        ]


class PAListSerializer(serializers.ModelSerializer):
    """Serializer for listing PAs (summary view)"""
    max_hours_per_week = serializers.SerializerMethodField()
    total_shifts = serializers.SerializerMethodField()
    total_hours = serializers.SerializerMethodField()
    reliability_score = serializers.SerializerMethodField()
    last_worked_date = serializers.SerializerMethodField()
    
    class Meta:
        model = User
        fields = [
            'id',
            'email',
            'first_name',
            'last_name',
            'phone_number',
            'is_email_verified',
            'is_active',
            'date_joined',
            'max_hours_per_week',
            'total_shifts',
            'total_hours',
            'reliability_score',
            'last_worked_date'
        ]
    
    def get_max_hours_per_week(self, obj):
        try:
            return obj.pa_profile.max_hours_per_week
        except:
            return 40
    
    def get_total_shifts(self, obj):
        try:
            return obj.schedule_stats.total_shifts_worked
        except:
            return 0
    
    def get_total_hours(self, obj):
        try:
            return float(obj.schedule_stats.total_hours_worked)
        except:
            return 0.0
    
    def get_reliability_score(self, obj):
        try:
            return float(obj.schedule_stats.reliability_score)
        except:
            return 100.0
    
    def get_last_worked_date(self, obj):
        try:
            return obj.schedule_stats.last_worked_date
        except:
            return None


class PADetailSerializer(serializers.ModelSerializer):
    """Detailed serializer for individual PA view"""
    profile = PAProfileSerializer(source='pa_profile', read_only=True)
    stats = PAScheduleStatsSerializer(source='schedule_stats', read_only=True)
    recent_shifts = serializers.SerializerMethodField()
    upcoming_shifts = serializers.SerializerMethodField()
    pending_requests = serializers.SerializerMethodField()
    
    class Meta:
        model = User
        fields = [
            'id',
            'email',
            'username',
            'first_name',
            'last_name',
            'phone_number',
            'is_email_verified',
            'is_active',
            'date_joined',
            'last_login',
            'profile',
            'stats',
            'recent_shifts',
            'upcoming_shifts',
            'pending_requests'
        ]
        read_only_fields = [
            'id',
            'email',
            'username',
            'date_joined',
            'last_login'
        ]
    
    def get_recent_shifts(self, obj):
        """Get last 10 completed shifts"""
        from datetime import date
        from apps.shifts.models import ShiftRequest
        
        shifts = ShiftRequest.objects.filter(
            requested_by=obj,
            status='APPROVED',
            date__lt=date.today()
        ).select_related('schedule_period').order_by('-date')[:10]
        
        return [{
            'id': shift.id,
            'date': shift.date,
            'start_time': shift.start_time,
            'end_time': shift.end_time,
            'duration_hours': float(shift.duration_hours),
            'schedule_period_name': shift.schedule_period.name
        } for shift in shifts]
    
    def get_upcoming_shifts(self, obj):
        """Get upcoming approved shifts"""
        from datetime import date
        from apps.shifts.models import ShiftRequest
        
        shifts = ShiftRequest.objects.filter(
            requested_by=obj,
            status='APPROVED',
            date__gte=date.today()
        ).select_related('schedule_period').order_by('date')[:10]
        
        return [{
            'id': shift.id,
            'date': shift.date,
            'start_time': shift.start_time,
            'end_time': shift.end_time,
            'duration_hours': float(shift.duration_hours),
            'schedule_period_name': shift.schedule_period.name
        } for shift in shifts]
    
    def get_pending_requests(self, obj):
        """Get pending shift requests"""
        from apps.shifts.models import ShiftRequest
        
        requests = ShiftRequest.objects.filter(
            requested_by=obj,
            status='PENDING'
        ).select_related('schedule_period').order_by('date')
        
        return [{
            'id': request.id,
            'date': request.date,
            'start_time': request.start_time,
            'end_time': request.end_time,
            'duration_hours': float(request.duration_hours),
            'schedule_period_name': request.schedule_period.name,
            'created_at': request.created_at
        } for request in requests]


class PAProfileUpdateSerializer(serializers.ModelSerializer):
    """Serializer for updating PA profile (admin only)"""
    class Meta:
        model = PAProfile
        fields = ['max_hours_per_week', 'notes']
```

# ==== apps/users/signals.py ====

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import User, PAProfile, PAScheduleStats


@receiver(post_save, sender=User)
def create_pa_profile(sender, instance, created, **kwargs):
    """
    Automatically create PAProfile and PAScheduleStats when a PA user is created.
    """
    if created and instance.role == 'PA':
        PAProfile.objects.get_or_create(user=instance)
        PAScheduleStats.objects.get_or_create(pa=instance)


@receiver(post_save, sender=User)
def save_pa_profile(sender, instance, **kwargs):
    """
    Save PAProfile when User is saved (if it exists).
    """
    if instance.role == 'PA' and hasattr(instance, 'pa_profile'):
        instance.pa_profile.save()
```

# ==== apps/users/tasks.py ====

```python
from celery import shared_task
from .utils import calculate_pa_patterns
import logging

logger = logging.getLogger(__name__)


@shared_task
def calculate_all_pa_patterns():
    """
    Calculate patterns for all PA users.
    Scheduled to run weekly (Monday 2 AM).
    """
    from apps.users.models import User
    
    pa_users = User.objects.filter(role='PA', is_active=True)
    
    success_count = 0
    error_count = 0
    
    for pa in pa_users:
        try:
            calculate_pa_patterns(pa.id)
            success_count += 1
            logger.info(f'Successfully calculated patterns for PA {pa.email}')
        except Exception as e:
            error_count += 1
            logger.error(f'Failed to calculate patterns for PA {pa.email}: {e}')
    
    logger.info(f'Pattern calculation complete: {success_count} success, {error_count} errors')
    return f'Calculated patterns for {success_count}/{pa_users.count()} PAs'
```

# ==== apps/users/templates/emails/password_reset.txt ====

```

ðŸ” PASSWORD RESET REQUEST

Hi {{ user_name }},

We received a request to reset your password for your PA Scheduling System account.

Password Reset Link:
{{ reset_url }}

This link will expire in 24 hours.

âš ï¸ SECURITY NOTICE:
If you didn't request a password reset, please ignore this email. Your password will remain unchanged.

Best regards,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/users/templates/emails/verification.txt ====

```
âœ‰ï¸ VERIFY YOUR EMAIL

Hi {{ user_name }},

Welcome to PA Scheduling System! Please verify your email address to complete your registration.

Verification Link:
{{ verification_url }}

This link will expire in 7 days.

If you didn't create an account, you can safely ignore this email.

Best regards,
PA Scheduling System

---
This is an automated message. Please do not reply to this email.
```

# ==== apps/users/tests.py ====

```python
from django.test import TestCase

# Create your tests here.
```

# ==== apps/users/urls.py ====

```python
from django.urls import path
from .views import (
    RegisterView,
    VerifyEmailView,
    LoginView,
    RefreshTokenView,
    LogoutView,
    PasswordResetRequestView,
    PasswordResetConfirmView,
    UserProfileView,
    UserListView,
    PAListView,
    PADetailView,
    PAProfileUpdateView,
    PAShiftHistoryView,
)

app_name = 'users'

urlpatterns = [
    # Authentication
    path('register/', RegisterView.as_view(), name='register'),
    path('verify-email/', VerifyEmailView.as_view(), name='verify-email'),
    path('login/', LoginView.as_view(), name='login'),
    path('refresh/', RefreshTokenView.as_view(), name='refresh'),
    path('logout/', LogoutView.as_view(), name='logout'),
    
    # Password Reset
    path('password-reset/', PasswordResetRequestView.as_view(), name='password-reset'),
    path('password-reset-confirm/', PasswordResetConfirmView.as_view(), name='password-reset-confirm'),
    
    # Profile & Users
    path('me/', UserProfileView.as_view(), name='user-profile'),
    path('users/', UserListView.as_view(), name='user-list'),
    
    # PA Management (Admin Only)
    path('pas/', PAListView.as_view(), name='pa-list'),
    path('pas/<int:id>/', PADetailView.as_view(), name='pa-detail'),
    path('pas/<int:user_id>/profile/', PAProfileUpdateView.as_view(), name='pa-profile-update'),
    path('pas/<int:id>/shift-history/', PAShiftHistoryView.as_view(), name='pa-shift-history'),
]
```

# ==== apps/users/utils.py ====

```python
from datetime import timedelta
from django.db.models import Count, Avg, Sum
from django.utils import timezone
from apps.shifts.models import ShiftRequest
from .models import PAScheduleStats


def calculate_pa_patterns(pa_id):
    """
    Calculate and update scheduling patterns for a PA user.
    Analyzes last 12 weeks of shift data.
    
    Args:
        pa_id: User ID of the PA
    
    Returns:
        PAScheduleStats instance
    """
    from apps.users.models import User, PAScheduleStats
    
    try:
        pa = User.objects.get(id=pa_id, role='PA')
    except User.DoesNotExist:
        return None
    
    # Get or create stats object
    stats, created = PAScheduleStats.objects.get_or_create(pa=pa)
    
    # Calculate date range (last 12 weeks)
    end_date = timezone.now().date()
    start_date = end_date - timedelta(weeks=12)
    
    # Get all approved shifts in date range
    shifts = ShiftRequest.objects.filter(
        requested_by=pa,
        status='APPROVED',
        date__gte=start_date,
        date__lte=end_date
    )
    
    # Lifetime statistics
    all_shifts = ShiftRequest.objects.filter(
        requested_by=pa,
        status='APPROVED'
    )
    
    stats.total_shifts_worked = all_shifts.count()
    stats.total_hours_worked = all_shifts.aggregate(
        total=Sum('duration_hours')
    )['total'] or 0
    
    # Average hours per week (last 12 weeks)
    if shifts.exists():
        total_hours_12_weeks = shifts.aggregate(
            total=Sum('duration_hours')
        )['total'] or 0
        stats.average_hours_per_week = total_hours_12_weeks / 12
    
    # Most common days
    day_counts = {}
    for shift in shifts:
        day_name = shift.date.strftime('%A').lower()
        day_counts[day_name] = day_counts.get(day_name, 0) + 1
    stats.most_common_days = day_counts
    
    # Most common start time
    if shifts.exists():
        start_times = shifts.values('start_time').annotate(
            count=Count('start_time')
        ).order_by('-count').first()
        
        if start_times:
            stats.most_common_start_time = start_times['start_time']
    
    # Most common shift length
    if shifts.exists():
        avg_length = shifts.aggregate(
            avg_duration=Avg('duration_hours')
        )['avg_duration']
        stats.most_common_shift_length = avg_length
    
    # Preferred shift pattern (morning/evening/full_day/mixed)
    morning_shifts = shifts.filter(start_time__hour__lt=12).count()
    evening_shifts = shifts.filter(start_time__hour__gte=18).count()
    total_shifts_counted = shifts.count()
    
    if total_shifts_counted > 0:
        morning_ratio = morning_shifts / total_shifts_counted
        evening_ratio = evening_shifts / total_shifts_counted
        
        if morning_ratio > 0.6:
            stats.preferred_shift_pattern = 'morning'
        elif evening_ratio > 0.6:
            stats.preferred_shift_pattern = 'evening'
        elif morning_ratio > 0.3 and evening_ratio > 0.3:
            stats.preferred_shift_pattern = 'full_day'
        else:
            stats.preferred_shift_pattern = 'mixed'
    
    # Reliability score (% of approved shifts not cancelled)
    total_requested = ShiftRequest.objects.filter(requested_by=pa).count()
    cancelled = ShiftRequest.objects.filter(
        requested_by=pa,
        status='CANCELLED'
    ).count()
    
    if total_requested > 0:
        stats.reliability_score = ((total_requested - cancelled) / total_requested) * 100
    
    # Typical request timing (days before shift)
    if shifts.exists():
        timing_diffs = []
        for shift in shifts[:50]:  # Sample last 50 shifts
            days_before = (shift.date - shift.created_at.date()).days
            if days_before >= 0:
                timing_diffs.append(days_before)
        
        if timing_diffs:
            stats.typical_request_timing = sum(timing_diffs) // len(timing_diffs)
    
    # Consecutive days preference
    if shifts.exists():
        dates = sorted([shift.date for shift in shifts])
        consecutive_counts = []
        current_streak = 1
        
        for i in range(1, len(dates)):
            if (dates[i] - dates[i-1]).days == 1:
                current_streak += 1
            else:
                if current_streak > 1:
                    consecutive_counts.append(current_streak)
                current_streak = 1
        
        if consecutive_counts:
            stats.consecutive_days_preference = sum(consecutive_counts) // len(consecutive_counts)
    
    # Last worked date
    if all_shifts.exists():
        stats.last_worked_date = all_shifts.latest('date').date
    
    stats.save()
    return stats
```

# ==== apps/users/views.py ====

```python
from rest_framework import status, generics, permissions
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import get_user_model
from django.shortcuts import get_object_or_404

from .serializers import (
    UserSerializer, 
    RegisterSerializer, 
    LoginSerializer,
    PasswordResetRequestSerializer,
    PasswordResetConfirmSerializer,
    EmailVerificationSerializer,
    UserProfileUpdateSerializer,
    PAListSerializer,
    PADetailSerializer,
    PAProfileUpdateSerializer,
)
from .models import EmailVerificationToken, PasswordResetToken, PAProfile
from .emails import send_verification_email, send_password_reset_email

User = get_user_model()


class RegisterView(generics.CreateAPIView):
    """
    POST: Register a new PA user
    Creates user and sends verification email
    """
    queryset = User.objects.all()
    serializer_class = RegisterSerializer
    permission_classes = [permissions.AllowAny]

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save()
        
        # Create verification token
        token = EmailVerificationToken.objects.create(user=user)
        
        # Send verification email (async with Celery)
        send_verification_email.delay(user.id, str(token.token))
        
        return Response({
            'message': 'Registration successful. Please check your email to verify your account.',
            'user': UserSerializer(user).data,
        }, status=status.HTTP_201_CREATED)


class VerifyEmailView(APIView):
    """
    POST: Verify email with token
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = EmailVerificationSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        token_uuid = serializer.validated_data['token']
        
        try:
            token = EmailVerificationToken.objects.get(token=token_uuid)
        except EmailVerificationToken.DoesNotExist:
            return Response(
                {'error': 'Invalid verification token.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if not token.is_valid():
            return Response(
                {'error': 'Verification token has expired or been used.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Mark token as used and verify user
        token.used = True
        token.save()
        
        user = token.user
        user.is_email_verified = True
        user.save()
        
        return Response({
            'message': 'Email verified successfully. You can now log in.',
            'user': UserSerializer(user).data
        }, status=status.HTTP_200_OK)


class LoginView(APIView):
    """
    POST: Login with email and password
    Returns JWT access and refresh tokens
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = LoginSerializer(data=request.data, context={'request': request})
        serializer.is_valid(raise_exception=True)
        
        user = serializer.validated_data['user']
        
        # Generate JWT tokens
        refresh = RefreshToken.for_user(user)
        
        return Response({
            'message': 'Login successful.',
            'user': UserSerializer(user).data,
            'tokens': {
                'refresh': str(refresh),
                'access': str(refresh.access_token),
            }
        }, status=status.HTTP_200_OK)


class RefreshTokenView(APIView):
    """
    POST: Refresh access token using refresh token
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        refresh_token = request.data.get('refresh')
        
        if not refresh_token:
            return Response(
                {'error': 'Refresh token is required.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        try:
            refresh = RefreshToken(refresh_token)
            return Response({
                'access': str(refresh.access_token)
            }, status=status.HTTP_200_OK)
        except Exception as e:
            return Response(
                {'error': 'Invalid or expired refresh token.'},
                status=status.HTTP_401_UNAUTHORIZED
            )


class LogoutView(APIView):
    """
    POST: Logout (blacklist refresh token)
    """
    permission_classes = [permissions.IsAuthenticated]
    
    def post(self, request):
        try:
            refresh_token = request.data.get('refresh')
            if refresh_token:
                token = RefreshToken(refresh_token)
                token.blacklist()
            return Response(
                {'message': 'Logout successful.'},
                status=status.HTTP_200_OK
            )
        except Exception:
            return Response(
                {'error': 'Invalid token.'},
                status=status.HTTP_400_BAD_REQUEST
            )


class PasswordResetRequestView(APIView):
    """
    POST: Request password reset email
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PasswordResetRequestSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        email = serializer.validated_data['email']
        
        try:
            user = User.objects.get(email=email)
            
            # Create reset token
            token = PasswordResetToken.objects.create(user=user)
            
            # Send reset email (async with Celery)
            send_password_reset_email.delay(user.id, str(token.token))
            
            return Response({
                'message': 'Password reset email sent. Please check your email.',
            }, status=status.HTTP_200_OK)
        except User.DoesNotExist:
            # Don't reveal if email exists (security best practice)
            return Response({
                'message': 'If that email exists, a password reset link has been sent.'
            }, status=status.HTTP_200_OK)


class PasswordResetConfirmView(APIView):
    """
    POST: Reset password with token
    """
    permission_classes = [permissions.AllowAny]
    
    def post(self, request):
        serializer = PasswordResetConfirmSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        token_uuid = serializer.validated_data['token']
        new_password = serializer.validated_data['password']
        
        try:
            token = PasswordResetToken.objects.get(token=token_uuid)
        except PasswordResetToken.DoesNotExist:
            return Response(
                {'error': 'Invalid reset token.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        if not token.is_valid():
            return Response(
                {'error': 'Reset token has expired or been used.'},
                status=status.HTTP_400_BAD_REQUEST
            )
        
        # Reset password
        user = token.user
        user.set_password(new_password)
        user.save()
        
        # Mark token as used
        token.used = True
        token.save()
        
        return Response({
            'message': 'Password reset successful. You can now log in with your new password.'
        }, status=status.HTTP_200_OK)


class UserProfileView(generics.RetrieveUpdateAPIView):
    """
    GET: Get current user profile
    PATCH: Update current user profile
    """
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_object(self):
        return self.request.user
    
    def get_serializer_class(self):
        if self.request.method == 'PATCH':
            return UserProfileUpdateSerializer
        return UserSerializer
    
class UserListView(generics.ListAPIView):
    """
    GET /api/auth/users/
    List all users (admin only) or filtered by role
    """
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAuthenticated]
    
    def get_queryset(self):
        queryset = User.objects.all().order_by('first_name', 'last_name')
        
        # Filter by role if provided
        role = self.request.query_params.get('role', None)
        if role:
            queryset = queryset.filter(role=role)
        
        # Optional: Only admins can see all users, PAs only see other PAs
        if self.request.user.role != 'ADMIN':
            queryset = queryset.filter(role='PA')
        
        return queryset
    
# ============= PA MANAGEMENT VIEWS (ADMIN ONLY) =============

class IsAdminUser(permissions.BasePermission):
    """Custom permission: only admin users"""
    def has_permission(self, request, view):
        return request.user and request.user.is_authenticated and request.user.role == 'ADMIN'


class PAListView(generics.ListAPIView):
    """
    GET /api/pas/
    List all PA users (admin only)
    """
    serializer_class = PAListSerializer
    permission_classes = [IsAdminUser]
    
    def get_queryset(self):
        return User.objects.filter(role='PA').select_related('pa_profile', 'schedule_stats').order_by('first_name', 'last_name')


class PADetailView(generics.RetrieveUpdateAPIView):
    """
    GET /api/pas/{id}/
    PATCH /api/pas/{id}/
    View and update individual PA (admin only)
    """
    permission_classes = [IsAdminUser]
    lookup_field = 'id'
    
    def get_queryset(self):
        return User.objects.filter(role='PA').select_related('pa_profile', 'schedule_stats')
    
    def get_serializer_class(self):
        if self.request.method == 'PATCH':
            return UserProfileUpdateSerializer
        return PADetailSerializer


class PAProfileUpdateView(generics.UpdateAPIView):
    """
    PATCH /api/pas/{id}/profile/
    Update PA profile settings (admin only)
    """
    serializer_class = PAProfileUpdateSerializer
    permission_classes = [IsAdminUser]
    lookup_field = 'user_id'
    
    def get_queryset(self):
        return PAProfile.objects.select_related('user').filter(user__role='PA')
    
    def get_object(self):
        user_id = self.kwargs.get('user_id')
        pa_profile = get_object_or_404(PAProfile, user_id=user_id)
        return pa_profile


class PAShiftHistoryView(APIView):
    """
    GET /api/pas/{id}/shift-history/
    Get all shifts for a PA with filtering (admin only)
    """
    permission_classes = [IsAdminUser]
    
    def get(self, request, id):
        from apps.shifts.models import ShiftRequest
        from apps.shifts.serializers import ShiftRequestSerializer
        
        # Get query params
        status = request.query_params.get('status')  # PENDING, APPROVED, REJECTED, CANCELLED
        start_date = request.query_params.get('start_date')
        end_date = request.query_params.get('end_date')
        
        # Base query
        shifts = ShiftRequest.objects.filter(requested_by_id=id).select_related('schedule_period', 'approved_by')
        
        # Apply filters
        if status:
            shifts = shifts.filter(status=status)
        if start_date:
            shifts = shifts.filter(date__gte=start_date)
        if end_date:
            shifts = shifts.filter(date__lte=end_date)
        
        # Order by date descending
        shifts = shifts.order_by('-date', '-created_at')
        
        serializer = ShiftRequestSerializer(shifts, many=True)
        return Response(serializer.data)
```

